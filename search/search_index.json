{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sonolus.py","text":""},{"location":"concepts/builtins/","title":"Builtins","text":"<p>Sonolus.py comes with support for a number of built-in functions.</p> <ul> <li><code>abs(x)</code></li> <li><code>bool(object)</code> (for a num argument)</li> <li><code>callable(object)</code></li> <li><code>enumerate(iterable, start=0)</code></li> <li><code>filter(function, iterable)</code></li> <li><code>float(x)</code> (for a num argument)</li> <li><code>int(x)</code> (for a num argument)</li> <li><code>isinstance(object, classinfo)</code></li> <li><code>issubclass(class, classinfo)</code></li> <li><code>len(s)</code></li> <li><code>map(function, iterable)</code></li> <li><code>max(iterable, *, key=None)</code>, <code>max(arg1, arg2, *args, key=None)</code></li> <li><code>min(iterable, *, key=None)</code>, <code>min(arg1, arg2, *args, key=None)</code></li> <li><code>range(stop)</code>, <code>range(start, stop[, step])</code></li> <li><code>reversed(seq)</code></li> <li><code>round(number[, ndigits])</code></li> <li><code>zip(*iterables)</code></li> </ul>"},{"location":"concepts/builtins/#standard-library-modules","title":"Standard library modules","text":"<p>Sonolus.py also comes with support for some standard library modules.</p>"},{"location":"concepts/builtins/#math","title":"math","text":"<ul> <li><code>sin(x)</code></li> <li><code>cos(x)</code></li> <li><code>tan(x)</code></li> <li><code>asin(x)</code></li> <li><code>acos(x)</code></li> <li><code>atan(x)</code></li> <li><code>atan2(y, x)</code></li> <li><code>sinh(x)</code></li> <li><code>cosh(x)</code></li> <li><code>tanh(x)</code></li> <li><code>floor(x)</code></li> <li><code>ceil(x)</code></li> <li><code>trunc(x)</code></li> <li><code>log(x[, base])</code></li> </ul>"},{"location":"concepts/builtins/#random","title":"random","text":"<ul> <li><code>randrange(stop)</code>, <code>random.randrange(start, stop[, step])</code></li> <li><code>randint(a, b)</code></li> <li><code>choice(seq)</code></li> <li><code>shuffle(seq)</code></li> <li><code>random()</code> (does not include 1)</li> <li><code>uniform(a, b)</code> (may include <code>b</code> where Python normally doesn't)</li> </ul> <p>Creating <code>Random</code> instances is not supported.</p>"},{"location":"concepts/constructs/","title":"Constructs","text":"<p>Most standard Python constructs are supported in Sonolus.py.</p>"},{"location":"concepts/constructs/#key-differences","title":"Key Differences","text":"<ul> <li>Non-num variables must have a single live definition.<ul> <li>If there are multiple definitions <code>var = ...</code> for a variable, the compiler must be able to determine that a single   one is active whenever the variable is used.</li> </ul> </li> <li>Conditional branches may be eliminated if they are determined to be unreachable</li> <li>Functions with non-num return types may not return multiple distinct objects<ul> <li>Most functions returning a non-num value should have a single return at the end</li> </ul> </li> <li>Destructuring assignment does not support the <code>*</code> operator.</li> <li>Sequence <code>match</code> patterns do not support the <code>*</code> operator.</li> <li>Mapping <code>match</code> patterns are unsupported.</li> <li>Imports may not be done within functions</li> <li>The <code>global</code> and <code>nonlocal</code> keywords are unsupported.</li> </ul>"},{"location":"concepts/constructs/#overview","title":"Overview","text":"<ul> <li>Expressions:<ul> <li>Literals:<ul> <li>Numbers (excluding complex numbers): <code>0</code>, <code>1</code>, <code>1.0</code>, <code>1e3</code>, <code>0x1</code>, <code>0b1</code>, <code>0o1</code></li> <li>Booleans: <code>True</code>, <code>False</code></li> <li>Strings: <code>'Hello, World!'</code>, <code>\"Hello, World!\"</code></li> <li>Tuples: <code>(1, 2, 3)</code></li> </ul> </li> <li>Operators (if supported by the operands):<ul> <li>Unary: <code>+</code>, <code>-</code>, <code>not</code>, <code>~</code></li> <li>Binary: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li> <li>Comparison: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>is</code>, <code>is not</code>, <code>in</code>, <code>not in</code></li> <li>Logical: <code>and</code>, <code>or</code> (for <code>Num</code> arguments only)</li> <li>Ternary: <code>a if &lt;condition&gt; else b</code> (for <code>Num</code> conditions only)</li> <li>Attribute: <code>a.b</code></li> <li>Indexing: <code>a[b]</code></li> <li>Call: <code>f(a, b, c)</code></li> </ul> </li> <li>Variables: <code>a</code>, <code>b</code>, <code>c</code></li> <li>Lambda: <code>lambda a, b: a + b</code></li> <li>Assignment Expression: <code>(a := b)</code></li> </ul> </li> <li>Statements:<ul> <li>Simple Statements:<ul> <li>Assignments:<ul> <li>Simple assignment: <code>a = b</code></li> <li>Augmented assignment: <code>a += b</code></li> <li>Attribute assignment: <code>a.b = c</code></li> <li>Index assignment: <code>a[b] = c</code></li> <li>Destructuring assignment: <code>a, b = b, a</code></li> <li>Multiple assignment: <code>a = b = c = 1</code></li> <li>Annotated assignment: <code>a: int = 1</code></li> </ul> </li> <li>Assert: <code>assert &lt;condition&gt;, &lt;message&gt;</code></li> <li>Pass: <code>pass</code></li> <li>Break: <code>break</code></li> <li>Continue: <code>continue</code></li> <li>Return: <code>return &lt;value&gt;</code></li> <li>Import: <code>import &lt;module&gt;</code>, <code>from &lt;module&gt; import &lt;name&gt;</code> (only outside of functions)</li> </ul> </li> <li>Compound Statements:<ul> <li>If: <code>if &lt;condition&gt;:</code>, <code>elif &lt;condition&gt;:</code>, <code>else:</code></li> <li>While: <code>while &lt;condition&gt;:</code>, <code>else:</code></li> <li>For: <code>for &lt;target&gt; in &lt;iterable&gt;:</code>, <code>else:</code></li> <li>Match: <code>match &lt;value&gt;:</code>, <code>case &lt;pattern&gt;:</code></li> <li>Function Definition: <code>def &lt;name&gt;(&lt;parameters&gt;):</code></li> <li>Class Definition: <code>class &lt;name&gt;:</code> (only outside of functions)</li> </ul> </li> </ul> </li> </ul>"},{"location":"concepts/constructs/#compile-time-evaluation","title":"Compile Time Evaluation","text":"<p>Some expressions can be evaluated at compile time:</p> <ul> <li>Numeric literals: <code>1</code>, <code>2.5</code>, <code>True</code>, <code>False</code>, ...</li> <li>None: <code>None</code></li> <li>Basic arithmetic: for compile time constant operands: <code>a + b</code>, <code>a - b</code>, <code>a * b</code>, <code>a / b</code>, ...</li> <li>Is/Is Not None: for any left-hand operand, <code>a is None</code>, <code>a is not None</code></li> <li>Type checks: for any value, <code>isinstance(a, t)</code>, <code>issubclass(a, t)</code></li> <li>Boolean operations:<ul> <li>Negation: <code>not a</code></li> <li>And<ul> <li>Both operands are compile time constants: <code>a and b</code></li> <li>One operand is known to be False: <code>False and a</code>, <code>a and False</code></li> </ul> </li> <li>Or<ul> <li>Both operands are compile time constants: <code>a or b</code></li> <li>One operand is known to be True: <code>True or a</code>, <code>a or True</code></li> </ul> </li> </ul> </li> <li>Comparison: for compile time constant operands: <code>a == b</code>, <code>a != b</code>, <code>a &gt; b</code>, <code>a &lt; b</code>, <code>a &gt;= b</code>, <code>a &lt;= b</code>, ...</li> <li>Variables assigned to compile time constants: <code>a = 1</code>, <code>b = a + 1</code>, ...</li> </ul> <p>The compiler can make additional inferences when compile time constants are used in certain contexts like control flow:</p> <pre><code>x = ...\n\n# This code works because the compiler knows which branch will be taken based on the type of 'x'\nif isinstance(x, Num):\n    debug_log(x)\nelif isinstance(x, Vec2):\n    debug_log(x.x + x.y)\nelse:\n    debug_log(-1)\n</code></pre>"},{"location":"concepts/constructs/#variables","title":"Variables","text":"<p>Variables can be assigned and used like in vanilla Python.</p> <pre><code>a = 1\nb = 2\nc = a + b\n</code></pre> <p>Unlike vanilla Python, non-num variables must have a single unambiguous definition when used. Nums have no such restriction.</p> <p>The following are allowed:</p> <pre><code>v = Vec2(1, 2)  # (1)\nv = Vec2(3, 4)  # (2)\ndebug_log(v.x + v.y)  # 'v' is valid because (2) is the only active definition\n</code></pre> <pre><code>v = 1  # (1)\nv = Vec2(3, 4)  # (2)\ndebug_log(v.x + v.y)  # 'v' is valid because (2) is the only active definition\n</code></pre> <pre><code>v = Vec2(1, 2)  # (1)\nwhile condition():\n    v = Vec2(3, 4)  # (2)\n    debug_log(v.x + v.y)  # 'v' is valid because (2) is the only active definition\n</code></pre> <pre><code>v = Vec2(1, 2)  # (1)\nif random() &lt; 0.5:\n    v @= Vec2(3, 4)  # Updates 'v' in-place without redefining it\ndebug_log(v.x + v.y)  # 'v' is valid because (1) is the only active definition\n</code></pre> <p>The following are not allowed:</p> <pre><code>v = Vec2(1, 2)  # (1)\nif random() &lt; 0.5:\n    v = Vec2(3, 4)  # (2)\ndebug_log(v.x + v.y)  # 'v' is invalid because both (1) and (2) are active\n</code></pre> <pre><code>v = Vec2(1, 2)  # (1)\nwhile condition():\n    debug_log(v.x + v.y)  # 'v' is invalid because (1) and (2) are active\n    v = Vec2(3, 4)  # (2) redefines 'v' for future iterations\n</code></pre>"},{"location":"concepts/constructs/#expressions","title":"Expressions","text":""},{"location":"concepts/constructs/#literals","title":"Literals","text":"<p><code>int</code>, <code>float</code>, <code>bool</code>, <code>str</code>, and <code>tuple</code> literals are supported:</p> <pre><code>a = 1\nb = 1.0\nc = True\nd = 'Hello, World!'\ne = (1, 2, 3)\n</code></pre>"},{"location":"concepts/constructs/#operators","title":"Operators","text":"<p>All standard operators are supported for types implementing them. <code>@=</code> is reserved as the copy-from operator.</p> <pre><code>a = 1 + 2\nb = 3 - 4\nc = 5 * 6\nd = 7 / 8\ne = Vec2(1, 2)\nf = e.x + e.y\ng = Array(1, 2, 3)\nh = g[0] + g[1] + g[2]\n(i := 1)\n</code></pre> <p>The ternary operator is supported for, but the condition must be a <code>Num</code>. If the operands are not nums, the condition must be a compile-time constant or this will be considered an error:</p> <pre><code># Ok\na = 1 if random() &lt; 0.5 else 2\nb = Vec2(1, 2) if b is None else b\n\n# Not ok\nc = Vec2(1, 2) if random() &lt; 0.5 else Vec2(3, 4)  # Multiple definitions\n</code></pre> <p>If the condition is a compile-time constant, then the ternary operator will be evaluated at compile time:</p> <pre><code>e = Vec2(0, 0) if e is None else e  # Ok, evaluated at compile time\n</code></pre>"},{"location":"concepts/constructs/#statements","title":"Statements","text":""},{"location":"concepts/constructs/#assignment","title":"Assignment","text":"<p>Most assignment types are supported. Destructuring assignment is supported only for tuples, and the <code>*</code> operator is not supported.</p> <pre><code># Ok\na = 1\nb += 2\nc.x = 3\nd[0] = 4\n(e, f), g = (1, 2), 3\n\n# Not ok\nh, *i = 1, 2, 3  # Not supported\n</code></pre> <pre><code>if a &gt; 0:\n    pass\n</code></pre>"},{"location":"concepts/constructs/#conditional-statements","title":"Conditional Statements","text":"<p>The standard conditional statements are supported.</p>"},{"location":"concepts/constructs/#if-elif-else","title":"if / elif / else","text":"<pre><code>if a &gt; 0:\n    ...\nelif a &lt; 0:\n    ...\nelse:\n    ...\n</code></pre> <p>When the condition is a compile-time constant, the compiler will remove the unreachable branches:</p> Code<pre><code>v = None\nif v is None:\n    v = Vec2(1, 2)\ndebug_log(v.x + v.y)\n</code></pre> Equivalent<pre><code>v = None\n# The 'if' branch is always taken\nv = Vec2(1, 2)\ndebug_log(v.x + v.y)\n</code></pre> <p>This is useful for handling optional arguments and supporting multiple argument types:</p> <pre><code>def f(a: Vec2 | None = None):\n    if a is None:\n        a = Vec2(1, 2)\n    debug_log(a.x + a.y)\n</code></pre> <pre><code>def f(a: Vec2 | int):\n    if isinstance(a, Vec2):\n        debug_log(a.x + a.y)\n    else:\n        debug_log(a)\n</code></pre>"},{"location":"concepts/constructs/#match-case","title":"match / case","text":"<p>The <code>match</code> statement is supported for matching values against patterns. All patterns, including subpatterns, except mapping patterns and sequences with the <code>*</code> operator are supported.  Records have a <code>__match_args__</code> attribute defined automatically, so they can be used with positional subpatterns.</p> <pre><code>match x:\n    case 1:\n        ...\n    case 2 | 3:\n        ...\n    case Vec2() as v:\n        ...\n    case (a, b):\n        ...\n    case Num(a):\n        ...\n    case _:\n        ...\n</code></pre> <p>As with <code>if</code> statements, the compiler will remove unreachable branches when the value is a compile-time constant:</p> Code<pre><code>v = 1\nmatch v:\n    case Vec2(a, b):\n        debug_log(a + b)\n    case Num():\n        debug_log(v)\n    case _:\n        debug_log(-1)\n</code></pre> Equivalent<pre><code>v = 1\n# 'case Num()' is always taken\ndebug_log(v)\n</code></pre>"},{"location":"concepts/constructs/#loops","title":"Loops","text":""},{"location":"concepts/constructs/#while-else","title":"while / else","text":"<p>While loops are fully supported, including the <code>else</code> clause and the <code>break</code> and <code>continue</code> statements.</p> <pre><code>while a &gt; 0:\n    if ...:\n        break\n    if ...:\n        continue\n    ...\nelse:\n    ...\n</code></pre>"},{"location":"concepts/constructs/#for-else","title":"for / else","text":"<p>For loops are supported, including the <code>else</code> clause and the <code>break</code> and <code>continue</code> statements. Custom iterators must subclass SonolusIterator.</p> <pre><code>for i in range(10):\n    if ...:\n        break\n    if ...:\n        continue\n    ...\nelse:\n    ...\n</code></pre> <p>Tuples can be iterated over and result in an unrolled loop. This can be useful for iterating of objects of different, types, but care should be taken since it results in more code being generated compared to a normal loop:</p> Code<pre><code>for i in (1, 2, 3):\n    debug_log(i)\n</code></pre> Equivalent<pre><code>debug_log(1)\ndebug_log(2)\ndebug_log(3)\n</code></pre>"},{"location":"concepts/constructs/#functions","title":"Functions","text":"<p>Functions and lambdas are supported, including within other functions:</p> <pre><code>def f(a, b):\n    return a + b\n\n\ndef g(a):\n    return lambda b: f(a, b)\n</code></pre> <p>Function returns follow the same rules as variable access. If a function returns a non-num value, it most only return that value. There is no restriction of a function only returns a num.</p> <p>The following are allowed:</p> <pre><code>def f():\n    return Vec2(1, 2)\n</code></pre> <pre><code>def g(x):\n    # Only one return is reachable since isinstance is evaluated at compile time\n    if isinstance(x, Vec2):\n        return Vec2(x.y, x.x)\n    else:\n        return x\n</code></pre> <pre><code>def h(x):\n    # Both returns return the exact same value\n    x = Vec2(1, 2)\n    if random() &lt; 0.5:\n        debug_log(123)\n        return x\n    else:\n        return x\n</code></pre> <pre><code>def i(x):\n    # All return values are nums\n    if random() &lt; 0.5:\n        return 1\n    return 2\n</code></pre> <p>The following are not allowed:</p> <pre><code>def j():\n    # Either return is reachable and return different values\n    if random() &lt; 0.5:\n        return Vec2(1, 2)\n    return Vec2(3, 4)\n</code></pre> <pre><code>def k():\n    # Both the return and an implicit 'return None' are reachable\n    if random() &lt; 0.5:\n        return Vec2(1, 2)\n</code></pre> <p>Most functions returning a non-num value should have a single <code>return</code> statement at the end.</p>"},{"location":"concepts/constructs/#classes","title":"Classes","text":"<p>Classes are supported at the module level. User defined classes should subclass <code>Record</code> or have a supported Sonolus.py decorator such as <code>@level_memory</code>.</p> <p>Methods may have the <code>@staticmethod</code>, <code>@classmethod</code>, or <code>@property</code> decorators.</p> <pre><code>class MyRecord(Record):\n    x: int\n    y: int\n\n    def regular_method(self):\n        ...\n\n    @staticmethod\n    def static_method():\n        ...\n\n    @classmethod\n    def class_method(cls):\n        ...\n\n    @property\n    def property(self):\n        ...\n</code></pre>"},{"location":"concepts/constructs/#imports","title":"Imports","text":"<p>Imports are supported at the module level, but not within functions.</p>"},{"location":"concepts/constructs/#assert","title":"assert","text":"<p>Assertions are supported. Since error handling is not supported, assertion failures will terminate the current callback when running in the Sonolus app.</p> <pre><code>assert a &gt; 0, 'a must be positive'\n</code></pre>"},{"location":"concepts/constructs/#pass","title":"pass","text":"<p>The <code>pass</code> statement is supported.</p>"},{"location":"concepts/resources/","title":"Resources","text":"<p>Sonolus.py supports declaring engine resources such as sprites, effects, and particles using decorators.</p>"},{"location":"concepts/types/","title":"Types","text":"<p>Sonolus.py has 3 core types: <code>Num</code>, <code>Array</code>, and <code>Record</code>. representing numeric values, fixed-size arrays,  and custom data structures, respectively. Arrays and records can be nested within each other to create complex data structures.</p> <p>Additionally, Sonolus.py supports the built-in types <code>tuple</code>, <code>dict</code>, <code>str</code>, classes and functions, and the constants <code>None</code>, <code>Ellipsis</code>, and <code>NotImplemented</code>.</p>"},{"location":"concepts/types/#num","title":"Num","text":"<p><code>Num</code> is the numeric and boolean type in Sonolus.py. It is interchangeable with <code>int</code>, <code>float</code>, and <code>bool</code>. Sonolus.py will treat any of these types as <code>Num</code>, but it's recommended to use what's appropriate for clarity.</p> <p>The Sonolus app uses 32-bit floating-point numbers for all numeric values, so precision may be lower compared to Python when running on Sonolus.</p> <p>Infinity, NaN, and values outside the range of 32-bit floating-point numbers are not supported.</p> <p>You can import <code>Num</code> from <code>sonolus.script.num</code>:</p> <pre><code>from sonolus.script.num import Num\n</code></pre>"},{"location":"concepts/types/#declaration","title":"Declaration","text":"<p>Nums can be declared using standard Python syntax.</p> <pre><code>a = 1\nb = 2.5\nc = True\n</code></pre>"},{"location":"concepts/types/#operations","title":"Operations","text":"<p>Nums support most of the standard Python operations:</p> <ul> <li>Comparison operators: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> <li>Arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code></li> <li>Unary operators: <code>+</code>, <code>-</code></li> </ul> <p>Nums are the only supported type for boolean operations and control flow conditions. As a condition, any nonzero value is considered true, and <code>0</code> is considered false.</p> <ul> <li>Logical operators: <code>and</code>, <code>or</code>, <code>not</code></li> <li>Ternary expressions: <code>... if &lt;condition&gt; else ...</code></li> <li>If statements: <code>if &lt;condition&gt;:</code>, <code>elif &lt;condition&gt;:</code></li> <li>While loops: <code>while &lt;condition&gt;:</code></li> <li>Case guards: <code>case ... if &lt;condition&gt;:</code></li> </ul>"},{"location":"concepts/types/#instance-checks","title":"Instance Checks","text":"<p>Since <code>Num</code> is interchangeable with <code>int</code>, <code>float</code>, and <code>bool</code>, only <code>Num</code> is supported for type checks.</p> <pre><code>x = ...\n\n# Ok:\nisinstance(x, Num)\n\nmatch x:\n    case Num(value):\n        ...\n\n# Not ok:\nisinstance(x, int)\nisinstance(x, float)\nisinstance(x, bool)\n\nmatch x:\n    case int(value):\n        ...\n    case float(value):\n        ...\n    case bool(value):\n        ...\n</code></pre>"},{"location":"concepts/types/#conversion","title":"Conversion","text":"<p>Calling <code>int</code>, <code>float</code>, or <code>bool</code> is only supported for an argument of type <code>Num</code>.</p> <p>Details:</p> <ul> <li><code>int</code>: Equivalent to <code>math.trunc</code>.</li> <li><code>float</code>: Validates that the value is a <code>Num</code> and returns it as is.</li> <li><code>bool</code>: Validates that the value is a <code>Num</code> and returns <code>1</code> for <code>True</code> and <code>0</code> for <code>False</code>.</li> </ul>"},{"location":"concepts/types/#array","title":"Array","text":"<p><code>Array[T, Size]</code> stores a fixed number of elements of the same type.</p> <p>It has two type parameters: - <code>T</code>: The type of the elements. - <code>Size</code>: The number of elements.</p> <p>You can import <code>Array</code> from <code>sonolus.script.array</code>:</p> <pre><code>from sonolus.script.array import Array\n</code></pre>"},{"location":"concepts/types/#declaration_1","title":"Declaration","text":"<p>Arrays can be created using its constructor:</p> <pre><code>a1 = Array[int, 3](1, 2, 3)\na2 = Array[int, 0]()\n</code></pre> <p>If at least one element is provided, the element type and size can be inferred:</p> <pre><code>a3 = Array(1, 2, 3)\n</code></pre> <p>Since <code>Array</code> takes type parameters, it is considered a generic type. A version of <code>Array</code> with type parameters provided is considered a concrete type.</p> <pre><code>Array  # The Generic Array type\nArray[int, 3]  # A concrete Array type\n</code></pre> <p>The element type of an array must be concrete (not generic) and the size must be a non-negative integer:</p> <pre><code># Ok\na4 = Array[Array[int, 3], 2](Array(1, 2, 3), Array(4, 5, 6))\n\n# Not ok:\na5 = Array[int, 0.5]()  # The size must be a non-negative integer\na6 = Array[Array, 2](Array(1, 2, 3), Array(4, 5, 6))  # The element type must be concrete (not generic)\n</code></pre> <p>Copies are made of any values provided to the constructor:</p> <pre><code>pair = Pair(1, 2)\na = Array[Pair, 1](pair)\nassert a[0] == Pair(1, 2)\n\npair.x = 3\nassert a[0] == Pair(1, 2)  # The value in the array is independent of the original value\n</code></pre>"},{"location":"concepts/types/#operations_1","title":"Operations","text":"<p>The value of an array can be copied from another array using the copy from operator (<code>@=</code>)<sup>1</sup>:</p> <pre><code>source_array = Array(1, 2, 3)\ndestination_array = Array(0, 0, 0)\n\ndestination_array @= source_array\nassert destination_array == Array(1, 2, 3)\n</code></pre> <p>Arrays can be compared for equality and inequality:</p> <pre><code>assert Array(1, 2, 3) == Array(1, 2, 3)\nassert Array(1, 2, 3) != Array(4, 5, 6)\n</code></pre> <p>Elements can be accessed by index:</p> <pre><code>a = Array(1, 2, 3)\nassert a[0] == 1\nassert a[1] == 2\nassert a[2] == 3\n</code></pre> <p>Elements can be updated by index, copying the given value into the corresponding element of the array:</p> <pre><code>a = Array(1, 2, 3)\na[0] = 4\nassert a == Array(4, 2, 3)\n</code></pre> <p>Warning</p> <p>If a value in an array is not a <code>Num</code>, updating it will copy the given value into the corresponding element of the array. However, that element remains independent of the original value, which may lead to unexpected results when updating either value.</p> <pre><code>pair = Pair(1, 2)\na = Array(Pair(0, 0))\n\na[0] = pair  # or equivalently: a[0] @= pair\nassert a[0] == Pair(1, 2)\n\npair.x = 3\nassert a[0] == Pair(1, 2)  # The value in the array is independent of the original value\n</code></pre> <p>For clarity, it's recommended to use the copy from operator (<code>@=</code>) when updating elements that are known to be an array or record (see the next section).</p> <pre><code>a[0] @= pair\n</code></pre> <p>The length of an array can be accessed using the <code>len()</code> function:</p> <pre><code>assert len(Array(1, 2, 3)) == 3\n</code></pre> <p>Arrays can be iterated over using a for loop:</p> <pre><code>a = Array(1, 2, 3)\n\nfor element in a:\n    debug_log(element)\n</code></pre> <p>Other functionality:</p> <p><code>Array</code> inherits from ArrayLike and supports all of its methods.</p>"},{"location":"concepts/types/#instance-checks_1","title":"Instance Checks","text":"<p>Any array is considered an instance of the generic <code>Array</code> type.</p> <pre><code>a = Array(1, 2, 3)\nassert isinstance(a, Array)\n</code></pre> <p>Only an array with the exact element type and size is considered an instance of a concrete <code>Array[T, Size]</code> type.</p> <pre><code>a = Array(1, 2, 3)\nassert isinstance(a, Array[int, 3])\nassert not isinstance(a, Array[int, 2])\nassert not isinstance(a, Array[Pair, 3])\n</code></pre>"},{"location":"concepts/types/#record","title":"Record","text":"<p><code>Record</code> is the base class for user-defined types in Sonolus.py. It functions similarly to dataclasses.</p> <p>You can import <code>Record</code> from <code>sonolus.script.record</code>:</p> <pre><code>from sonolus.script.record import Record\n</code></pre>"},{"location":"concepts/types/#declaration_2","title":"Declaration","text":"<p>A record can be defined by inheriting from <code>Record</code> and defining zero or more fields as class attributes:</p> <pre><code>class MyPair(Record):\n    first: int\n    second: int\n</code></pre> <p>Fields must be annotated by <code>Num</code> (or equivalently <code>int</code>, <code>float</code>, or <code>bool</code>),  a concrete array type, or a concrete record type.</p> <pre><code># Not ok:\nclass MyRecord(Record):\n    array: Array  # Array is not concrete since it has unspecified type parameters\n</code></pre> <p>A <code>Record</code> subclass cannot be further subclassed.</p> <pre><code># Not ok:\nclass MyPairSubclass(MyPair):\n    third: int\n</code></pre>"},{"location":"concepts/types/#instantiation","title":"Instantiation","text":"<p>A constructor is automatically generated for the <code>Record</code> class:</p> <pre><code>pair_1 = MyPair(1, 2)\npair_2 = MyPair(first=1, second=2)\n</code></pre>"},{"location":"concepts/types/#generics","title":"Generics","text":"<p><code>Record</code> supports generics. If at least one type parameter is provided in the class definition, a generic  record type is created.</p> <pre><code>class MyGenericPair[T, U](Record):\n    first: T\n    second: U\n\nclass ContainsArray[T, Size](Record):\n    array: Array[T, Size]\n</code></pre> <p>Generic type parameters can be specified explicitly when instantiating a generic or inferred from the provided values:</p> <pre><code>pair_1 = MyGenericPair[int, int](1, 2)\npair_2 = MyGenericPair(1, 2)\n</code></pre> <p>The value of a type parameter can be accessed via the <code>type_var_value()</code> classmethod.</p> <pre><code>class MyGenericRecord[T](Record):\n    value: T\n\n    def my_type(self) -&gt; type:\n        return self.type_var_value(T)\n\n\nassert MyGenericRecord(1).my_type() == Num\n</code></pre>"},{"location":"concepts/types/#operations_2","title":"Operations","text":"<p>The value of a record can be copied from another record using the copy from operator (<code>@=</code>)<sup>1</sup>:</p> <pre><code>source_record = MyPair(1, 2)\ndestination_record = MyPair(0, 0)\n\ndestination_record @= source_record\nassert destination_record == MyPair(1, 2)\n</code></pre> <p>Records can be compared for equality and inequality:</p> <pre><code>assert MyPair(1, 2) == MyPair(1, 2)\nassert MyPair(1, 2) != MyPair(3, 4)\n</code></pre> <p>Dunder methods can be implemented to define custom behavior for records:</p> <pre><code>class MyAddablePair(Record):\n    first: int\n    second: int\n\n    def __add__(self, other: MyAddablePair) -&gt; MyAddablePair:\n        return MyAddablePair(self.first + other.first, self.second + other.second)\n</code></pre> <p>If a dunder method has an in-place variant and the in-place method is not explicitly implemented (e.g. <code>__iadd__</code> is the in-place variant of <code>__add__</code>), <code>Record</code> will automatically generate one that  modifies the instance in place:</p> <pre><code>pair = MyAddablePair(1, 2)\nreference = pair\npair += MyAddablePair(3, 4)\nassert pair == reference == MyAddablePair(4, 6)  # The instance is modified in place\n</code></pre> <p>Regular methods, properties, classmethods, and staticmethods can also be defined in a <code>Record</code> subclass.</p> <pre><code>class MyRecord(Record):\n    def my_method(self):\n        ...\n\n    @property\n    def my_property(self):\n        ...\n\n    @property.setter\n    def my_property(self, value):\n        ...\n\n    @classmethod\n    def my_classmethod(cls):\n        ...\n\n    @staticmethod\n    def my_staticmethod():\n        ...\n</code></pre> <p>Fields can be accessed and updated using the dot operator:</p> <pre><code>pair = MyPair(1, 2)\nassert pair.first == 1\nassert pair.second == 2\n\npair.first = 3\nassert pair == MyPair(3, 2)\n</code></pre> <p>Warning</p> <p>If a value in a record is not a <code>Num</code>, updating it will copy the given value into the corresponding field of the record. However, that field remains independent of the original value.</p> <pre><code>array = Array(1, 2, 3)\nrecord = MyRecord(array)\n\nrecord.array = Array(4, 5, 6)  # or equivalently: record.array @= Array(4, 5, 6)\nassert record.array == Array(4, 5, 6)\n\narray[0] = 7\nassert record.array == Array(4, 5, 6)  # The value in the record is independent of the original\n</code></pre> <p>For clarity, it's recommended to use the copy from operator (<code>@=</code>) when updating fields that are known to be an array or record.</p> <pre><code>record.array @= array\n</code></pre>"},{"location":"concepts/types/#instance-checks_2","title":"Instance Checks","text":"<p>Any record is considered an instance of the generic <code>Record</code> type:</p> <pre><code>pair = MyPair(1, 2)\nassert isinstance(pair, Record)\n</code></pre> <p>If a record is generic, any instance of it is considered an instance of the generic type:</p> <pre><code>pair = MyGenericPair[int, int](1, 2)\nassert isinstance(pair, MyGenericPair)\n</code></pre> <p>Only an instance of a record with the exact field types is considered an instance of a concrete <code>Record</code> type:</p> <pre><code>pair = MyPair(1, 2)\nassert isinstance(pair, MyPair[int, int])\nassert not isinstance(pair, MyPair[int, Array[int, 2]])\n</code></pre>"},{"location":"concepts/types/#transient-types","title":"Transient Types","text":"<p>In addition to the standard types, the following transient types are available. Compared to the standard types, these types come with the restriction that they cannot be used as type parameters or as a Record field's type. Otherwise, they can be used like any other type, including passing instances of them as  arguments to functions.</p>"},{"location":"concepts/types/#tuple","title":"tuple","text":"<p>The built-in <code>tuple</code> type can be declared and destructured as usual:</p> <pre><code>t = (1, (2, 3))\na, (b, c) = t\n</code></pre> <p>Tuples may be indexed, but the given index must be a compile-time constant:</p> <pre><code>t = (1, 2, 3)\n\n# Ok\ndebug_log(t[0])\n\n# Not ok:\ndebug_log(t[random_integer(0, 2)])\n</code></pre> <p>They may also be created as an *args argument to a function and unpacked as an argument to a function:</p> <pre><code>def f1(a, b, c):\n    return a + b + c\n\ndef f2(*args):\n    return f1(*args)\n</code></pre> <p>Iterating over a tuple is also supported, but they are expanded at compile time, so iterating over large tuples may significantly increase the size of the compiled engine and slow down compilation:</p> <pre><code>t = (1, 2, 3)\nfor x in t:\n    debug_log(x)\n</code></pre>"},{"location":"concepts/types/#dict","title":"dict","text":"<p>Dicts can be created by the **kwargs syntax and unpacked as arguments to a function:</p> <pre><code>def f1(a, b):\n    return a + b\n\ndef f2(**kwargs):\n    return f1(**kwargs)\n</code></pre>"},{"location":"concepts/types/#str","title":"str","text":"<p>Strings can be created and compared for equality and inequality:</p> <pre><code>s1 = 'abc'\ns2 = 'def'\n\nassert s1 == 'abc'\nassert s1 != s2\n</code></pre>"},{"location":"concepts/types/#special-constants","title":"Special Constants","text":"<p>The built-in <code>None</code>, <code>Ellipsis</code>, and <code>NotImplemented</code> constants are supported.</p> <p><code>None</code> is the only supported right-side operand for the <code>is</code> and <code>is not</code> operators.</p> <pre><code>a = None\nb = 1\n\n# Ok\na is None\nb is not None\n\n# Not ok:\nb is b\n</code></pre>"},{"location":"concepts/types/#other-types","title":"Other types","text":"<p>Classes themselves are considered instances of <code>type</code>. They may be used as arguments to functions, but annotating a record field as <code>type</code> or declaring an array with element type <code>type</code> is not supported.</p> <p>Functions or methods may be used as arguments to functions, but annotating a record field or setting an array element type to <code>Callable</code> is not supported.</p>"},{"location":"concepts/types/#storing-instances-of-transient-types-in-records","title":"Storing Instances of Transient Types in Records","text":"<p>Warning</p> <p>The following is advanced usage and is unnecessary for most use cases.</p> <p>While transient types cannot be used as type parameters or as a Record field's type, it is possible to store them in a generic record in a field annotated by a type parameter. Type arguments must not be explicitly provided when doing so. If multiple fields are annotated by the same type parameter, all such fields may be required to hold the exact same value in some cases.</p> <p>For example, a version of the <code>filter</code> function can be implemented as follows (see Iterables  for more information on iterators):</p> <pre><code>class _FilteringIterator[T, Fn](Record, SonolusIterator):\n    fn: Fn\n    iterator: T\n\n    def has_next(self) -&gt; bool:\n        while self.iterator.has_next():\n            if self.fn(self.iterator.get()):\n                return True\n            self.iterator.advance()\n        return False\n\n    def get(self) -&gt; Any:\n        return self.iterator.get()\n\n    def advance(self):\n        self.iterator.advance()\n\n\ndef my_filter[T, Fn](iterable: T, fn: Fn) -&gt; T:\n    return _FilteringIterator(fn, iterable.__iter__())\n</code></pre> <ol> <li> <p>The copy from operator (<code>@=</code>) is officially the in-place matrix multiplication operator in Python, but it has been repurposed in Sonolus.py for copying Arrays and Records.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"reference/builtins/","title":"builtins","text":""},{"location":"reference/builtins/#doc_stubs.builtins.abs","title":"<code>abs(x)</code>","text":"<p>Return the absolute value of a number.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int | float</code> <p>A number.</p> required <p>Returns:</p> Type Description <code>int | float</code> <p>The absolute value of x.</p>"},{"location":"reference/builtins/#doc_stubs.builtins.bool","title":"<code>bool(x)</code>","text":"<p>Convert a value to a Boolean.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int | float | bool</code> <p>The value to convert.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The Boolean value of x.</p>"},{"location":"reference/builtins/#doc_stubs.builtins.callable","title":"<code>callable(obj)</code>","text":"<p>Check if the object appears callable.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the object appears callable, False otherwise.</p>"},{"location":"reference/builtins/#doc_stubs.builtins.enumerate","title":"<code>enumerate(iterable, start=0)</code>","text":"<p>Return an enumerate object.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[T]</code> <p>The iterable to enumerate.</p> required <code>start</code> <code>int</code> <p>The starting index.</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterator[tuple[int, T]]</code> <p>An enumerate object.</p>"},{"location":"reference/builtins/#doc_stubs.builtins.filter","title":"<code>filter(function, iterable)</code>","text":"<p>Construct an iterator from those elements of iterable for which function returns true.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[[T], bool] | None</code> <p>A function that tests if each element should be included. If None, returns the elements that are true.</p> required <code>iterable</code> <code>Iterable[T]</code> <p>The iterable to filter.</p> required <p>Returns:</p> Type Description <code>Iterator[T]</code> <p>An iterator yielding the filtered elements.</p>"},{"location":"reference/builtins/#doc_stubs.builtins.float","title":"<code>float(x)</code>","text":"<p>Convert a number to a floating point number.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int | float</code> <p>The number to convert.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The floating point representation of x.</p>"},{"location":"reference/builtins/#doc_stubs.builtins.int","title":"<code>int(x)</code>","text":"<p>Convert a number to an integer.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int | float</code> <p>The number to convert.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The integer representation of x.</p>"},{"location":"reference/builtins/#doc_stubs.builtins.isinstance","title":"<code>isinstance(obj, classinfo)</code>","text":"<p>Check if an object is an instance of a class or of a subclass thereof.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object to check.</p> required <code>classinfo</code> <code>type | tuple[type, ...]</code> <p>A type or a tuple of types.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the object is an instance of classinfo, False otherwise.</p>"},{"location":"reference/builtins/#doc_stubs.builtins.issubclass","title":"<code>issubclass(cls, classinfo)</code>","text":"<p>Check if a class is a subclass of another class or a tuple of classes.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The class to check.</p> required <code>classinfo</code> <code>type | tuple[type, ...]</code> <p>A class or a tuple of classes.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if cls is a subclass of classinfo, False otherwise.</p>"},{"location":"reference/builtins/#doc_stubs.builtins.len","title":"<code>len(s)</code>","text":"<p>Return the number of items in a container.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>object</code> <p>The container object.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of items in s.</p>"},{"location":"reference/builtins/#doc_stubs.builtins.map","title":"<code>map(function, iterable)</code>","text":"<p>Apply a function to every item of an iterable and return an iterator.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[[T], S]</code> <p>The function to apply.</p> required <code>iterable</code> <code>Iterable[T]</code> <p>The iterable to process.</p> required <p>Returns:</p> Type Description <code>Iterator[S]</code> <p>An iterator with the results.</p>"},{"location":"reference/builtins/#doc_stubs.builtins.reversed","title":"<code>reversed(seq)</code>","text":"<p>Return a reverse iterator.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>Sequence[T]</code> <p>The sequence to reverse.</p> required <p>Returns:</p> Type Description <code>Iterator[T]</code> <p>An iterator over the reversed sequence.</p>"},{"location":"reference/builtins/#doc_stubs.builtins.round","title":"<code>round(number, ndigits=...)</code>","text":"<p>Round a number to a given precision in decimal digits.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int | float</code> <p>The number to round.</p> required <code>ndigits</code> <code>int</code> <p>The number of decimal digits to round to.</p> <code>...</code> <p>Returns:</p> Type Description <code>float</code> <p>The rounded number.</p>"},{"location":"reference/builtins/#doc_stubs.builtins.zip","title":"<code>zip(*iterables)</code>","text":"<p>Return an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences.</p> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[T]</code> <p>Iterables to aggregate.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iterator[tuple[T, ...]]</code> <p>An iterator of aggregated tuples.</p>"},{"location":"reference/math/","title":"math","text":""},{"location":"reference/math/#doc_stubs.math.acos","title":"<code>acos(x)</code>","text":"<p>Compute the arccosine of x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>A value between -1 and 1.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The arccosine of x in radians.</p>"},{"location":"reference/math/#doc_stubs.math.asin","title":"<code>asin(x)</code>","text":"<p>Compute the arcsine of x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>A value between -1 and 1.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The arcsine of x in radians.</p>"},{"location":"reference/math/#doc_stubs.math.atan","title":"<code>atan(x)</code>","text":"<p>Compute the arctangent of x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>A numeric value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The arctangent of x in radians.</p>"},{"location":"reference/math/#doc_stubs.math.atan2","title":"<code>atan2(y, x)</code>","text":"<p>Compute the arctangent of y / x considering the quadrant.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>float</code> <p>The y-coordinate.</p> required <code>x</code> <code>float</code> <p>The x-coordinate.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The arctangent of y / x in radians.</p>"},{"location":"reference/math/#doc_stubs.math.ceil","title":"<code>ceil(x)</code>","text":"<p>Return the smallest integer greater than or equal to x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>A numeric value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ceiling of x.</p>"},{"location":"reference/math/#doc_stubs.math.cos","title":"<code>cos(x)</code>","text":"<p>Compute the cosine of x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The angle in radians.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The cosine of x.</p>"},{"location":"reference/math/#doc_stubs.math.cosh","title":"<code>cosh(x)</code>","text":"<p>Compute the hyperbolic cosine of x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>A numeric value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The hyperbolic cosine of x.</p>"},{"location":"reference/math/#doc_stubs.math.floor","title":"<code>floor(x)</code>","text":"<p>Return the largest integer less than or equal to x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>A numeric value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The floor of x.</p>"},{"location":"reference/math/#doc_stubs.math.log","title":"<code>log(x, base=...)</code>","text":"<p>Compute the logarithm of x to the given base.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The number for which to compute the logarithm.</p> required <code>base</code> <code>float</code> <p>The base of the logarithm. If omitted, returns the natural logarithm of x.</p> <code>...</code> <p>Returns:</p> Type Description <code>float</code> <p>The logarithm of x to the specified base.</p>"},{"location":"reference/math/#doc_stubs.math.sin","title":"<code>sin(x)</code>","text":"<p>Compute the sine of x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The angle in radians.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The sine of x.</p>"},{"location":"reference/math/#doc_stubs.math.sinh","title":"<code>sinh(x)</code>","text":"<p>Compute the hyperbolic sine of x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>A numeric value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The hyperbolic sine of x.</p>"},{"location":"reference/math/#doc_stubs.math.tan","title":"<code>tan(x)</code>","text":"<p>Compute the tangent of x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The angle in radians.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The tangent of x.</p>"},{"location":"reference/math/#doc_stubs.math.tanh","title":"<code>tanh(x)</code>","text":"<p>Compute the hyperbolic tangent of x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>A numeric value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The hyperbolic tangent of x.</p>"},{"location":"reference/math/#doc_stubs.math.trunc","title":"<code>trunc(x)</code>","text":"<p>Truncate x to the nearest integer towards zero.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>A numeric value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The truncated integer value of x.</p>"},{"location":"reference/random/","title":"random","text":""},{"location":"reference/random/#doc_stubs.random.choice","title":"<code>choice(seq)</code>","text":"<p>Return a randomly selected element from a non-empty sequence.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>Sequence[T]</code> <p>The sequence to choose from.</p> required <p>Returns:</p> Type Description <code>T</code> <p>A randomly selected element from the sequence.</p>"},{"location":"reference/random/#doc_stubs.random.randint","title":"<code>randint(a, b)</code>","text":"<p>Return a random integer N such that a &lt;= N &lt;= b.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>The lower bound.</p> required <code>b</code> <code>int</code> <p>The upper bound.</p> required <p>Returns:</p> Type Description <code>int</code> <p>A randomly selected integer between a and b, inclusive.</p>"},{"location":"reference/random/#doc_stubs.random.random","title":"<code>random()</code>","text":"<p>Return a random floating point number in the range [0.0, 1.0).</p> <p>Returns:</p> Type Description <code>float</code> <p>A random float between 0.0 (inclusive) and 1.0 (exclusive).</p>"},{"location":"reference/random/#doc_stubs.random.shuffle","title":"<code>shuffle(seq)</code>","text":"<p>Shuffle the sequence in place.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>MutableSequence[Any]</code> <p>The mutable sequence to shuffle.</p> required"},{"location":"reference/random/#doc_stubs.random.uniform","title":"<code>uniform(a, b)</code>","text":"<p>Return a random floating point number N such that a &lt;= N &lt;= b.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The lower bound.</p> required <code>b</code> <code>float</code> <p>The upper bound.</p> required <p>Returns:</p> Type Description <code>float</code> <p>A random float between a and b.</p>"},{"location":"reference/sonolus.script.archetype/","title":"sonolus.script.archetype","text":""},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.ArchetypeLife","title":"<code>ArchetypeLife</code>","text":"<p>               Bases: <code>Record</code></p> <p>How an entity contributes to life.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.ArchetypeLife.good_increment","title":"<code>good_increment: Num</code>  <code>instance-attribute</code>","text":"<p>Life increment for a good judgment.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.ArchetypeLife.great_increment","title":"<code>great_increment: Num</code>  <code>instance-attribute</code>","text":"<p>Life increment for a great judgment.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.ArchetypeLife.miss_increment","title":"<code>miss_increment: Num</code>  <code>instance-attribute</code>","text":"<p>Life increment for a miss judgment.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.ArchetypeLife.perfect_increment","title":"<code>perfect_increment: Num</code>  <code>instance-attribute</code>","text":"<p>Life increment for a perfect judgment.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.ArchetypeLife.update","title":"<code>update(perfect_increment=None, great_increment=None, good_increment=None, miss_increment=None)</code>","text":"<p>Update the life increments.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.EntityRef","title":"<code>EntityRef</code>","text":"<p>               Bases: <code>Record</code></p> <p>Reference to another entity.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype","title":"<code>PlayArchetype</code>","text":"<p>               Bases: <code>_BaseArchetype</code></p> <p>Base class for play mode archetypes.</p> Usage <pre><code>class MyArchetype(PlayArchetype):\n    # Set to True if the entity is a note and contributes to combo and score\n    # Default is False\n    is_scored: bool = True\n\n    imported_field: int = imported()\n    exported_field: int = exported()\n    entity_memory_field: int = entity_memory()\n    shared_memory_field: int = shared_memory()\n\n    @callback(order=1)\n    def preprocess(self):\n        ...\n</code></pre>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.despawn","title":"<code>despawn</code>  <code>property</code> <code>writable</code>","text":"<p>Whether the entity should be despawned after this frame.</p> <p>Setting this to True will despawn the entity.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.index","title":"<code>index: int</code>  <code>property</code>","text":"<p>The index of this entity.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.is_active","title":"<code>is_active: bool</code>  <code>property</code>","text":"<p>Whether this entity is active.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.is_despawned","title":"<code>is_despawned: bool</code>  <code>property</code>","text":"<p>Whether this entity is despawned.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.is_scored","title":"<code>is_scored: bool = False</code>  <code>class-attribute</code>","text":"<p>Whether the entity contributes to combo and score.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.is_waiting","title":"<code>is_waiting: bool</code>  <code>property</code>","text":"<p>Whether this entity is waiting to be spawned.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.life","title":"<code>life: ArchetypeLife</code>  <code>property</code>","text":"<p>How this entity contributes to life.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.name","title":"<code>name: str | None = None</code>  <code>class-attribute</code>","text":"<p>The name of the archetype.</p> <p>If not set, the name will be the class name.</p> <p>The name is used in level data.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.result","title":"<code>result: PlayEntityInput</code>  <code>property</code>","text":"<p>The result of this entity.</p> <p>Only meaningful for scored entities.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.initialize","title":"<code>initialize()</code>","text":"<p>Initialize this entity.</p> <p>Runs when this entity is spawned.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.preprocess","title":"<code>preprocess()</code>","text":"<p>Perform upfront processing.</p> <p>Runs first when the level is loaded.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.ref","title":"<code>ref()</code>","text":"<p>Get a reference to this entity for creating level data.</p> <p>Not valid elsewhere.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.should_spawn","title":"<code>should_spawn()</code>","text":"<p>Return whether the entity should be spawned.</p> <p>Runs when this entity is first in the spawn queue.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.spawn","title":"<code>spawn(**kwargs)</code>  <code>classmethod</code>","text":"<p>Spawn an entity of this archetype, injecting the given values into entity memory.</p> Usage <pre><code>class MyArchetype(PlayArchetype):\n    field: int = entity_memory()\n\ndef f():\n    MyArchetype.spawn(field=123)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Entity memory values to inject by field name as defined in the Archetype.</p> <code>{}</code>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.spawn_order","title":"<code>spawn_order()</code>","text":"<p>Return the spawn order of the entity.</p> <p>Runs when the level is loaded after <code>preprocess</code>.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.terminate","title":"<code>terminate()</code>","text":"<p>Finalize before despawning.</p> <p>Runs when the entity is despawned.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.touch","title":"<code>touch()</code>","text":"<p>Handle user input.</p> <p>Runs after <code>update_sequential</code> each frame.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.update_parallel","title":"<code>update_parallel()</code>","text":"<p>Perform parallel actions for this frame.</p> <p>Runs after <code>touch</code> each frame.</p> <p>This is where most gameplay logic should be placed.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PlayArchetype.update_sequential","title":"<code>update_sequential()</code>","text":"<p>Perform non-parallel actions for this frame.</p> <p>Runs first each frame.</p> <p>This is where logic affecting shared memory should be placed. Other logic should be placed in <code>update_parallel</code> for better performance.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PreviewArchetype","title":"<code>PreviewArchetype</code>","text":"<p>               Bases: <code>_BaseArchetype</code></p> <p>Base class for preview mode archetypes.</p> Usage <pre><code>class MyArchetype(PreviewArchetype):\n    imported_field: int = imported()\n    entity_memory_field: int = entity_memory()\n    shared_memory_field: int = shared_memory()\n\n    @callback(order=1)\n    def preprocess(self):\n        ...\n</code></pre>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PreviewArchetype.index","title":"<code>index: int</code>  <code>property</code>","text":"<p>The index of this entity.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PreviewArchetype.name","title":"<code>name: str | None = None</code>  <code>class-attribute</code>","text":"<p>The name of the archetype.</p> <p>If not set, the name will be the class name.</p> <p>The name is used in level data.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PreviewArchetype.preprocess","title":"<code>preprocess()</code>","text":"<p>Perform upfront processing.</p> <p>Runs first when the level is loaded.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PreviewArchetype.render","title":"<code>render()</code>","text":"<p>Render the entity.</p> <p>Runs after <code>preprocess</code>.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.PreviewArchetype.spawn","title":"<code>spawn(**kwargs)</code>  <code>classmethod</code>","text":"<p>Spawn an entity of this archetype, injecting the given values into entity memory.</p> Usage <pre><code>class MyArchetype(PlayArchetype):\n    field: int = entity_memory()\n\ndef f():\n    MyArchetype.spawn(field=123)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Entity memory values to inject by field name as defined in the Archetype.</p> <code>{}</code>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.StandardArchetypeName","title":"<code>StandardArchetypeName</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Standard archetype names.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.StandardArchetypeName.BPM_CHANGE","title":"<code>BPM_CHANGE = '#BPM_CHANGE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Bpm change marker</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.StandardArchetypeName.TIMESCALE_CHANGE","title":"<code>TIMESCALE_CHANGE = '#TIMESCALE_CHANGE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Timescale change marker</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.StandardImport","title":"<code>StandardImport</code>","text":"<p>Standard import annotations for Archetype fields.</p> Usage <pre><code>class MyArchetype(WatchArchetype):\n    judgment: StandardImport.JUDGMENT\n</code></pre>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.StandardImport.ACCURACY","title":"<code>ACCURACY = Annotated[float, imported(name='#ACCURACY')]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The accuracy of the entity.</p> <p>Automatically supported in watch mode for archetypes with a corresponding scored play mode archetype.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.StandardImport.BEAT","title":"<code>BEAT = Annotated[float, imported(name='#BEAT')]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The beat of the entity.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.StandardImport.BPM","title":"<code>BPM = Annotated[float, imported(name='#BPM')]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The bpm, for bpm change markers.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.StandardImport.JUDGMENT","title":"<code>JUDGMENT = Annotated[int, imported(name='#JUDGMENT')]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The judgment of the entity.</p> <p>Automatically supported in watch mode for archetypes with a corresponding scored play mode archetype.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.StandardImport.TIMESCALE","title":"<code>TIMESCALE = Annotated[float, imported(name='#TIMESCALE')]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The timescale, for timescale change markers.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype","title":"<code>WatchArchetype</code>","text":"<p>               Bases: <code>_BaseArchetype</code></p> <p>Base class for watch mode archetypes.</p> Usage <pre><code>class MyArchetype(WatchArchetype):\n    imported_field: int = imported()\n    entity_memory_field: int = entity_memory()\n    shared_memory_field: int = shared_memory()\n\n    @callback(order=1)\n    def update_sequential(self):\n        ...\n</code></pre>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype.index","title":"<code>index: int</code>  <code>property</code>","text":"<p>The index of this entity.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype.is_active","title":"<code>is_active: bool</code>  <code>property</code>","text":"<p>Whether this entity is active.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype.life","title":"<code>life: ArchetypeLife</code>  <code>property</code>","text":"<p>How this entity contributes to life.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype.name","title":"<code>name: str | None = None</code>  <code>class-attribute</code>","text":"<p>The name of the archetype.</p> <p>If not set, the name will be the class name.</p> <p>The name is used in level data.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype.result","title":"<code>result: WatchEntityInput</code>  <code>property</code>","text":"<p>The result of this entity.</p> <p>Only meaningful for scored entities.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype.target_time","title":"<code>target_time: float</code>  <code>property</code> <code>writable</code>","text":"<p>The target time of this entity.</p> <p>Only meaningful for scored entities. Determines when combo and score are updated.</p> <p>Alias of <code>result.target_time</code>.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype.despawn_time","title":"<code>despawn_time()</code>","text":"<p>Return the despawn time of the entity.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype.initialize","title":"<code>initialize()</code>","text":"<p>Initialize this entity.</p> <p>Runs when this entity is spawned.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype.preprocess","title":"<code>preprocess()</code>","text":"<p>Perform upfront processing.</p> <p>Runs first when the level is loaded.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype.spawn","title":"<code>spawn(**kwargs)</code>  <code>classmethod</code>","text":"<p>Spawn an entity of this archetype, injecting the given values into entity memory.</p> Usage <pre><code>class MyArchetype(PlayArchetype):\n    field: int = entity_memory()\n\ndef f():\n    MyArchetype.spawn(field=123)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Entity memory values to inject by field name as defined in the Archetype.</p> <code>{}</code>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype.spawn_time","title":"<code>spawn_time()</code>","text":"<p>Return the spawn time of the entity.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype.terminate","title":"<code>terminate()</code>","text":"<p>Finalize before despawning.</p> <p>Runs when the entity is despawned.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype.update_parallel","title":"<code>update_parallel()</code>","text":"<p>Parallel update callback.</p> <p>Runs after <code>touch</code> each frame.</p> <p>This is where most gameplay logic should be placed.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.WatchArchetype.update_sequential","title":"<code>update_sequential()</code>","text":"<p>Perform non-parallel actions for this frame.</p> <p>Runs first each frame.</p> <p>This is where logic affecting shared memory should be placed. Other logic should be placed in <code>update_parallel</code> for better performance.</p>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.callback","title":"<code>callback(*, order=0)</code>","text":"<p>Annotate a callback with its order.</p> <p>Callbacks are execute from lowest to highest order. By default, callbacks have an order of 0.</p> Usage <pre><code>class MyArchetype(PlayArchetype):\n    @callback(order=1)\n    def update_sequential(self):\n        pass\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>int</code> <p>The order of the callback. Lower values are executed first.</p> <code>0</code>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.entity_memory","title":"<code>entity_memory()</code>","text":"<p>Declare a field as entity memory.</p> <p>Entity memory is private to the entity and is not accessible from other entities.</p> <p>Entity memory fields may also be set when an entity is spawned using the <code>spawn()</code> method.</p> Usage <pre><code>class MyArchetype(PlayArchetype):\n    field: int = entity_memory()\n</code></pre>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.exported","title":"<code>exported(*, name=None)</code>","text":"<p>Declare a field as exported.</p> <p>This is only usable in play mode to export data to be loaded in watch mode.</p> <p>Exported fields are write-only.</p> Usage <pre><code>class MyArchetype(PlayArchetype):\n    field: int = exported()\n    field_with_explicit_name: int = exported(name=\"#FIELD\")\n</code></pre>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.imported","title":"<code>imported(*, name=None)</code>","text":"<p>Declare a field as imported.</p> <p>Imported fields may be loaded from the level data.</p> <p>In watch mode, data may also be loaded from a corresponding exported field in play mode.</p> <p>Imported fields may only be updated in the <code>preprocess</code> callback, and are read-only in other callbacks.</p> Usage <pre><code>class MyArchetype(PlayArchetype):\n    field: int = imported()\n    field_with_explicit_name: int = imported(name=\"field_name\")\n</code></pre>"},{"location":"reference/sonolus.script.archetype/#sonolus.script.archetype.shared_memory","title":"<code>shared_memory()</code>","text":"<p>Declare a field as shared memory.</p> <p>Shared memory is accessible from other entities.</p> <p>Shared memory may only be updated by sequential callbacks such as <code>preprocess</code>, <code>update_sequential</code>, and <code>touch</code>.</p> Usage <pre><code>class MyArchetype(PlayArchetype):\n    field: int = shared_memory()\n</code></pre>"},{"location":"reference/sonolus.script.array_like/","title":"sonolus.script.array_like","text":""},{"location":"reference/sonolus.script.array_like/#sonolus.script.array_like.ArrayLike","title":"<code>ArrayLike</code>","text":"<p>               Bases: <code>Sequence</code>, <code>ABC</code></p> <p>Mixin for array-like objects.</p> <p>Inheritors must implement <code>__len__</code>, <code>__getitem__</code>, and <code>__setitem__</code>.</p> Usage <pre><code>class MyArrayLike[T](Record, ArrayLike[T]):\n    def __len__(self) -&gt; int:\n        ...\n\n    def __getitem__(self, index: Num) -&gt; T:\n        ...\n\n    def __setitem__(self, index: Num, value: T):\n        ...\n</code></pre>"},{"location":"reference/sonolus.script.array_like/#sonolus.script.array_like.ArrayLike.__contains__","title":"<code>__contains__(value)</code>","text":"<p>Return whether any element in the array is equal to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to check for.</p> required"},{"location":"reference/sonolus.script.array_like/#sonolus.script.array_like.ArrayLike.__getitem__","title":"<code>__getitem__(index)</code>  <code>abstractmethod</code>","text":"<p>Return the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Num</code> <p>The index of the item. Must be an integer between 0 and <code>len(self) - 1</code>.</p> required"},{"location":"reference/sonolus.script.array_like/#sonolus.script.array_like.ArrayLike.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the array.</p>"},{"location":"reference/sonolus.script.array_like/#sonolus.script.array_like.ArrayLike.__len__","title":"<code>__len__()</code>  <code>abstractmethod</code>","text":"<p>Return the length of the array.</p>"},{"location":"reference/sonolus.script.array_like/#sonolus.script.array_like.ArrayLike.__reversed__","title":"<code>__reversed__()</code>","text":"<p>Return a reversed view of the array.</p>"},{"location":"reference/sonolus.script.array_like/#sonolus.script.array_like.ArrayLike.__setitem__","title":"<code>__setitem__(index, value)</code>  <code>abstractmethod</code>","text":"<p>Set the value of the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Num</code> <p>The index of the item. Must be an integer between 0 and <code>len(self) - 1</code>.</p> required <code>value</code> <code>T</code> <p>The value to set.</p> required"},{"location":"reference/sonolus.script.array_like/#sonolus.script.array_like.ArrayLike.count","title":"<code>count(value)</code>","text":"<p>Return the number of elements in the array equal to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to count.</p> required"},{"location":"reference/sonolus.script.array_like/#sonolus.script.array_like.ArrayLike.index","title":"<code>index(value, start=0, stop=None)</code>","text":"<p>Return the index of the value in the array equal to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to search for.</p> required <code>start</code> <code>Num</code> <p>The index to start searching from.</p> <code>0</code> <code>stop</code> <code>Num | None</code> <p>The index to stop searching at. If <code>None</code>, search to the end of the array.</p> <code>None</code>"},{"location":"reference/sonolus.script.array_like/#sonolus.script.array_like.ArrayLike.last_index","title":"<code>last_index(value)</code>","text":"<p>Return the last index of the value in the array equal to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to search for.</p> required"},{"location":"reference/sonolus.script.array_like/#sonolus.script.array_like.ArrayLike.reverse","title":"<code>reverse()</code>","text":"<p>Reverse the values in the array in place.</p>"},{"location":"reference/sonolus.script.array_like/#sonolus.script.array_like.ArrayLike.shuffle","title":"<code>shuffle()</code>","text":"<p>Shuffle the values in the array in place.</p>"},{"location":"reference/sonolus.script.array_like/#sonolus.script.array_like.ArrayLike.sort","title":"<code>sort(*, key=None, reverse=False)</code>","text":"<p>Sort the values in the array in place.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[T, Any] | None</code> <p>A one-argument ordering function to use for comparison.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>If <code>True</code>, sort in descending order, otherwise sort in ascending order.</p> <code>False</code>"},{"location":"reference/sonolus.script.array_like/#sonolus.script.array_like.ArrayLike.swap","title":"<code>swap(i, j)</code>","text":"<p>Swap the values at the given indices.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>Num</code> <p>The first index.</p> required <code>j</code> <code>Num</code> <p>The second index.</p> required"},{"location":"reference/sonolus.script.iterator/","title":"sonolus.script.iterator","text":""},{"location":"reference/sonolus.script.record/","title":"sonolus.script.record","text":"<p>For usage details, see the corresponding concepts page.</p>"},{"location":"reference/sonolus.script.record/#sonolus.script.record.Record","title":"<code>Record</code>","text":"<p>               Bases: <code>GenericValue</code></p> <p>The base class for user-defined data structures.</p> Usage <p>A regular record: <pre><code>class MyRecord(Record):\n    field1: int\n    field2: bool\n</code></pre></p> <p>A generic record: <pre><code>class MyGenericRecord[T, U](Record):\n    field1: T\n    field2: U\n</code></pre></p>"},{"location":"reference/sonolus.script.record/#sonolus.script.record.Record.type_var_value","title":"<code>type_var_value(var)</code>  <code>classmethod</code>","text":"<p>Return the value of a type variable.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>TypeVar</code> <p>The type variable to get the value of.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value of the type variable.</p>"}]}