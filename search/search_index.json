{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sonolus.py","text":""},{"location":"reference/iterables/","title":"Iterators","text":""},{"location":"reference/types/","title":"Types","text":"<p>Sonolus.py compes with support for a number of Python built-in types and some custom types.</p>"},{"location":"reference/types/#num","title":"Num","text":"<p><code>Num</code> is the numeric and boolean type in Sonolus.py. It is interchangeable with <code>int</code>, <code>float</code>, and <code>bool</code>. Sonolus.py will treat any of these types as <code>Num</code>, but it's recommended to use what's appropriate for clarity.</p> <p>The Sonolus app uses 32-bit floating-point numbers for all numeric values, so precision may be lower compared to Python when running on Sonolus.</p> <p>Infinity, NaN, and values outside the range of 32-bit floating-point numbers are not supported.</p> <p>You can import <code>Num</code> from <code>sonolus.script.num</code>:</p> <pre><code>from sonolus.script.num import Num\n</code></pre>"},{"location":"reference/types/#declaration","title":"Declaration","text":"<p>Instances of <code>Num</code> can be declared using standard Python syntax.</p> <pre><code>a = 1\nb = 2.5\nc = True\n</code></pre>"},{"location":"reference/types/#operations","title":"Operations","text":"<p><code>Num</code> supports most of the standard Python operations:</p> <ul> <li>Comparison operators: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> <li>Arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code></li> <li>Unary operators: <code>+</code>, <code>-</code></li> </ul> <p><code>Num</code> is also the only supported type for boolean operations and control flow conditions. Any nonzero value is considered <code>True</code>, and <code>0</code> is considered <code>False</code>.</p> <ul> <li>Logical operators: <code>and</code>, <code>or</code>, <code>not</code></li> <li>Ternary expressions: <code>... if &lt;condition&gt; else ...</code></li> <li>If statements: <code>if &lt;condition&gt;:</code>, <code>elif &lt;condition&gt;:</code></li> <li>While loops: <code>while &lt;condition&gt;:</code></li> <li>Case guards: <code>case ... if &lt;condition&gt;:</code></li> </ul>"},{"location":"reference/types/#instance-checks","title":"Instance Checks","text":"<p>Since <code>Num</code> is interchangeable with <code>int</code>, <code>float</code>, and <code>bool</code>, only <code>Num</code> is supported for type checks.</p> <pre><code>x = ...\n\n# Ok:\nisinstance(x, Num)\n\nmatch x:\n    case Num(value):\n        ...\n\n# Not ok:\nisinstance(x, int)\nisinstance(x, float)\nisinstance(x, bool)\n\nmatch x:\n    case int(value):\n        ...\n    case float(value):\n        ...\n    case bool(value):\n        ...\n</code></pre>"},{"location":"reference/types/#conversion","title":"Conversion","text":"<p>Calling <code>int</code>, <code>float</code>, or <code>bool</code> is only supported for an argument of type <code>Num</code>.</p> <p>Details:</p> <ul> <li><code>int</code>: Equivalent to <code>math.trunc</code>.</li> <li><code>float</code>: Validates that the value is a <code>Num</code> and returns it as is.</li> <li><code>bool</code>: Validates that the value is a <code>Num</code> and returns <code>1</code> for <code>True</code> and <code>0</code> for <code>False</code>.</li> </ul>"},{"location":"reference/types/#array","title":"Array","text":"<p><code>Array[T, Size]</code> stores a fixed number of elements of the same type.</p> <p>It has two type parameters: - <code>T</code>: The type of the elements. - <code>Size</code>: The number of elements.</p> <p>You can import <code>Array</code> from <code>sonolus.script.array</code>:</p> <pre><code>from sonolus.script.array import Array\n</code></pre>"},{"location":"reference/types/#declaration_1","title":"Declaration","text":"<p>Arrays can be created using its constructor:</p> <pre><code>a1 = Array[int, 3](1, 2, 3)\na2 = Array[int, 0]()\n</code></pre> <p>If at least one element is provided, the element type and size can be inferred:</p> <pre><code>a3 = Array(1, 2, 3)\n</code></pre> <p>The element type must be concrete (not generic) and the size must be a non-negative integer:</p> <pre><code># Ok\na4 = Array[Array[int, 3], 2](Array(1, 2, 3), Array(4, 5, 6))\n\n# Not ok:\na5 = Array[int, 0.5]()  # The size must be a non-negative integer\na6 = Array[Array, 2](Array(1, 2, 3), Array(4, 5, 6))  # The element type must be concrete (not generic)\n</code></pre> <p>Copies are made of any values provided to the constructor:</p> <pre><code>pair = Pair(1, 2)\na = Array[Pair, 1](pair)\nassert a[0] == Pair(1, 2)\n\npair.x = 3\nassert a[0] == Pair(1, 2)  # The value in the array is independent of the original value\n</code></pre>"},{"location":"reference/types/#operations_1","title":"Operations","text":"<p>The value of an array can be copied from another array using the copy from operator (<code>@=</code>)<sup>1</sup>:</p> <pre><code>source_array = Array(1, 2, 3)\ndestination_array = Array(0, 0, 0)\n\ndestination_array @= source_array\nassert destination_array == Array(1, 2, 3)\n</code></pre> <p>Arrays can be compared for equality and inequality:</p> <pre><code>assert Array(1, 2, 3) == Array(1, 2, 3)\nassert Array(1, 2, 3) != Array(4, 5, 6)\n</code></pre> <p>Elements can be accessed by index:</p> <pre><code>a = Array(1, 2, 3)\nassert a[0] == 1\nassert a[1] == 2\nassert a[2] == 3\n</code></pre> <p>Elements can be updated by index, copying the given value into the corresponding element of the array:</p> <pre><code>a = Array(1, 2, 3)\na[0] = 4\nassert a == Array(4, 2, 3)\n</code></pre> <p>Warning</p> <p>If a value in an array is not a <code>Num</code>, updating it will copy the given value into the corresponding element of the array. However, that element remains independent of the original value.</p> <pre><code>pair = Pair(1, 2)\na = Array(Pair(0, 0))\n\na[0] = pair  # or equivalently: a[0] @= pair\nassert a[0] == Pair(1, 2)\n\npair.x = 3\nassert a[0] == Pair(1, 2)  # The value in the array is independent of the original value\n</code></pre> <p>For clarity, it's recommended to use the copy from operator (<code>@=</code>) when updating elements that are known to be an array or record (see the next section).</p> <pre><code>a[0] @= pair\n</code></pre> <p>The length of an array can be accessed using the <code>len()</code> function:</p> <pre><code>assert len(Array(1, 2, 3)) == 3\n</code></pre> <p>Arrays can be iterated over using a for loop:</p> <pre><code>a = Array(1, 2, 3)\n\nfor element in a:\n    debug_log(element)\n</code></pre> <p>Other functionality:</p> <p>Array inherits from ArrayLike and supports all of its methods.</p>"},{"location":"reference/types/#instance-checks_1","title":"Instance Checks","text":"<p>Any array is considered an instance of the generic <code>Array</code> type.</p> <pre><code>a = Array(1, 2, 3)\nassert isinstance(a, Array)\n</code></pre> <p>Only an array with the exact element type and size is considered an instance of a concrete <code>Array[T, Size]</code> type.</p> <pre><code>a = Array(1, 2, 3)\nassert isinstance(a, Array[int, 3])\nassert not isinstance(a, Array[int, 2])\nassert not isinstance(a, Array[Pair, 3])\n</code></pre>"},{"location":"reference/types/#record","title":"Record","text":"<p><code>Record</code> is the base class for user-defined types in Sonolus.py. It functions similarly to dataclasses.</p> <p>You can import <code>Record</code> from <code>sonolus.script.record</code>:</p> <pre><code>from sonolus.script.record import Record\n</code></pre>"},{"location":"reference/types/#declaration_2","title":"Declaration","text":"<p>A <code>Record</code> class can be defined by inheriting from <code>Record</code> and defining zero or more fields as class attributes:</p> <pre><code>class MyPair(Record):\n    first: int\n    second: int\n</code></pre> <p>Fields must be annotated by <code>Num</code> (or equivalently <code>int</code>, <code>float</code>, or <code>bool</code>), a concrete <code>Array</code>, or a concrete <code>Record</code>.</p> <pre><code># Not ok:\nclass MyRecord(Record):\n    array: Array  # Array is not concrete since it has unspecified type parameters\n</code></pre> <p>A <code>Record</code> subclass cannot be further subclassed.</p> <pre><code># Not ok:\nclass MyPairSubclass(MyPair):\n    third: int\n</code></pre>"},{"location":"reference/types/#instantiation","title":"Instantiation","text":"<p>A constructor is automatically generated for the <code>Record</code> class:</p> <pre><code>pair_1 = MyPair(1, 2)\npair_2 = MyPair(first=1, second=2)\n</code></pre>"},{"location":"reference/types/#generics","title":"Generics","text":"<p><code>Record</code> supports generics:</p> <pre><code>class MyGenericPair[T, U](Record):\n    first: T\n    second: U\n\nclass ContainsArray[T, Size](Record):\n    array: Array[T, Size]\n</code></pre> <p>Generic type parameters can be specified when instantiating a generic or inferred from the provided values:</p> <pre><code>pair_1 = MyGenericPair[int, int](1, 2)\npair_2 = MyGenericPair(1, 2)\n</code></pre> <p>The value of a type parameter can be accessed via the <code>type_var_value()</code> classmethod.</p> <pre><code>class MyGenericRecord[T](Record):\n    value: T\n\n    def my_type(self) -&gt; type:\n        return self.type_var_value(T)\n</code></pre>"},{"location":"reference/types/#operations_2","title":"Operations","text":"<p>The value of a record can be copied from another record using the copy from operator (<code>@=</code>)<sup>1</sup>:</p> <pre><code>source_record = MyPair(1, 2)\ndestination_record = MyPair(0, 0)\n\ndestination_record @= source_record\nassert destination_record == MyPair(1, 2)\n</code></pre> <p>Records can be compared for equality and inequality:</p> <pre><code>assert MyPair(1, 2) == MyPair(1, 2)\nassert MyPair(1, 2) != MyPair(3, 4)\n</code></pre> <p>Dunder methods can be implemented to define custom behavior for records:</p> <pre><code>class MyAddablePair(Record):\n    first: int\n    second: int\n\n    def __add__(self, other: MyAddablePair) -&gt; MyAddablePair:\n        return MyAddablePair(self.first + other.first, self.second + other.second)\n</code></pre> <p>If a dunder method has an in-place variant and the in-place method is not explicitly implemented (e.g. <code>__iadd__</code> is the in-place variant of <code>__add__</code>), <code>Record</code> will automatically generate one that  modifies the instance in place:</p> <pre><code>pair = MyAddablePair(1, 2)\nreference = pair\npair += MyAddablePair(3, 4)\nassert pair == reference == MyAddablePair(4, 6)  # The instance is modified in place\n</code></pre> <p>Regular methods, properties, classmethods, and staticmethods can also be defined in a <code>Record</code> subclass.</p> <pre><code>class MyRecord(Record):\n    def my_method(self):\n        ...\n\n    @property\n    def my_property(self):\n        ...\n\n    @property.setter\n    def my_property(self, value):\n        ...\n\n    @classmethod\n    def my_classmethod(cls):\n        ...\n\n    @staticmethod\n    def my_staticmethod():\n        ...\n</code></pre> <p>Fields can be accessed and updated using the dot operator:</p> <pre><code>pair = MyPair(1, 2)\nassert pair.first == 1\nassert pair.second == 2\n\npair.first = 3\nassert pair == MyPair(3, 2)\n</code></pre> <p>Warning</p> <p>If a value in a record is not a <code>Num</code>, updating it will copy the given value into the corresponding field of the record. However, that field remains independent of the original value.</p> <pre><code>array = Array(1, 2, 3)\nrecord = MyRecord(array)\n\nrecord.array = Array(4, 5, 6)  # or equivalently: record.array @= Array(4, 5, 6)\nassert record.array == Array(4, 5, 6)\n\narray[0] = 7\nassert record.array == Array(4, 5, 6)  # The value in the record is independent of the original\n</code></pre> <p>For clarity, it's recommended to use the copy from operator (<code>@=</code>) when updating fields that are known to be an array or record.</p> <pre><code>record.array @= array\n</code></pre>"},{"location":"reference/types/#instance-checks_2","title":"Instance Checks","text":"<p>Any record is considered an instance of the generic <code>Record</code> type:</p> <pre><code>pair = MyPair(1, 2)\nassert isinstance(pair, Record)\n</code></pre> <p>If a record is generic, any instance of it is considered an instance of the generic type:</p> <pre><code>pair = MyGenericPair[int, int](1, 2)\nassert isinstance(pair, MyGenericPair)\n</code></pre> <p>Only an instance of a record with the exact field types is considered an instance of a concrete <code>Record</code> type:</p> <pre><code>pair = MyPair(1, 2)\nassert isinstance(pair, MyPair[int, int])\nassert not isinstance(pair, MyPair[int, Array[int, 2]])\n</code></pre>"},{"location":"reference/types/#transient-types","title":"Transient Types","text":"<p>In addition to the standard types, the following transient types are available. Compared to the standard types, these types come with the restriction that they cannot be used as type parameters or as a Record field's type. Otherwise, they can be used like any other type, including passing instances of them as  arguments to functions.</p>"},{"location":"reference/types/#tuple","title":"tuple","text":"<p>The built-in <code>tuple</code> type can be declared and destructured as usual:</p> <pre><code>t = (1, (2, 3))\na, (b, c) = t\n</code></pre> <p>Tuples may be indexed, but the given index must be a compile-time constant:</p> <pre><code>t = (1, 2, 3)\n\n# Ok\ndebug_log(t[0])\n\n# Not ok:\ndbmsg_log(t[random_integer(0, 2)])\n</code></pre> <p>They may also be created as an *args argument to a function and unpacked as an argument to a function:</p> <pre><code>def f1(a, b, c):\n    return a + b + c\n\ndef f2(*args):\n    return f1(*args)\n</code></pre> <p>Iterating over a tuple is also supported, but they are expanded at compile time, so iterating over large tuples may significantly increase the size of the compiled engine and slow down compilation:</p> <pre><code>t = (1, 2, 3)\nfor x in t:\n    debug_log(x)\n</code></pre>"},{"location":"reference/types/#dict","title":"dict","text":"<p>Dicts can be created by the **kwargs syntax and unpacked as arguments to a function:</p> <pre><code>def f1(a, b):\n    return a + b\n\ndef f2(**kwargs):\n    return f1(**kwargs)\n</code></pre>"},{"location":"reference/types/#special-constants","title":"Special Constants","text":"<p>The built-in <code>None</code>, <code>Ellipsis</code>, and <code>NotImplemented</code> constants are supported.</p> <p><code>None</code> is the only supported right-side operand for the <code>is</code> and <code>is not</code> operators.</p> <pre><code>a = None\nb = 1\n\n# Ok\nassert a is None\nassert b is not None\n\n# Not ok:\nassert b is b\n</code></pre>"},{"location":"reference/types/#other-types","title":"Other types","text":"<p>Classes themselves are considered instances of <code>type</code>. They may be used as arguments to functions, but annotating a record field as <code>type</code> or declaring an array with element type <code>type</code> is not supported.</p> <p>Functions or methods may be used as arguments to functions, but annotating a record field or setting an array element type to <code>Callable</code> is not supported.</p>"},{"location":"reference/types/#storing-instances-of-transient-types-in-records","title":"Storing Instances of Transient Types in Records","text":"<p>Warning</p> <p>The following is advanced usage and is unnecessary for most use cases.</p> <p>While transient types cannot be used as type parameters or as a Record field's type, it is possible to store them in a generic record in a field annotated by a type parameter. Type arguments must not be explicitly provided when doing so. If multiple fields are annotated by the same type parameter, all such fields may be required to hold the exact same value in some cases.</p> <p>For example, a version of the <code>filter</code> function can be implemented as follows (see Iterables for more information on iterators):</p> <pre><code>class _FilteringIterator[T, Fn](Record, SonolusIterator):\n    fn: Fn\n    iterator: T\n\n    def has_next(self) -&gt; bool:\n        while self.iterator.has_next():\n            if self.fn(self.iterator.get()):\n                return True\n            self.iterator.advance()\n        return False\n\n    def get(self) -&gt; Any:\n        return self.iterator.get()\n\n    def advance(self):\n        self.iterator.advance()\n\n\ndef my_filter[T, Fn](iterable: T, fn: Fn) -&gt; T:\n    return _FilteringIterator(fn, iterable.__iter__())\n</code></pre> <ol> <li> <p>The copy from operator (<code>@=</code>) is officially the in-place matrix multiplication operator in Python, but it has been repurposed in Sonolus.py for copying Arrays and Records.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"reference/standard_library/array_like/","title":"ArrayLike[T]","text":"<p>               Bases: <code>Sequence</code>, <code>ABC</code></p> <p>Mixin for array-like objects.</p> <p>Inheritor must implement <code>__len__</code>, <code>__getitem__</code>, and <code>__setitem__</code>.</p> Usage <pre><code>class MyArrayLike[T](Record, ArrayLike[T]):\n    def __len__(self) -&gt; int:\n        ...\n\n    def __getitem__(self, index: Num) -&gt; T:\n        ...\n\n    def __setitem__(self, index: Num, value: T):\n        ...\n</code></pre>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.__contains__","title":"<code>__contains__(value)</code>","text":"<p>Returns whether any element in the array is equal to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to check for.</p> required"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.__getitem__","title":"<code>__getitem__(index)</code>  <code>abstractmethod</code>","text":"<p>Returns the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Num</code> <p>The index of the item. Must be an integer between 0 and <code>len(self) - 1</code>.</p> required"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.__iter__","title":"<code>__iter__()</code>","text":"<p>Returns an iterator over the array.</p>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.__len__","title":"<code>__len__()</code>  <code>abstractmethod</code>","text":"<p>Returns the length of the array.</p>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.__reversed__","title":"<code>__reversed__()</code>","text":"<p>Returns a reversed view of the array.</p>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.__setitem__","title":"<code>__setitem__(index, value)</code>  <code>abstractmethod</code>","text":"<p>Sets the value of the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Num</code> <p>The index of the item. Must be an integer between 0 and <code>len(self) - 1</code>.</p> required <code>value</code> <code>T</code> <p>The value to set.</p> required"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.count","title":"<code>count(value)</code>","text":"<p>Returns the number of elements in the array equal to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to count.</p> required"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.index","title":"<code>index(value, start=0, stop=None)</code>","text":"<p>Returns the index of the value in the array equal to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to search for.</p> required <code>start</code> <code>Num</code> <p>The index to start searching from.</p> <code>0</code> <code>stop</code> <code>Num | None</code> <p>The index to stop searching at. If <code>None</code>, search to the end of the array.</p> <code>None</code>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.last_index","title":"<code>last_index(value)</code>","text":"<p>Returns the last index of the value in the array equal to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to search for.</p> required"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.reverse","title":"<code>reverse()</code>","text":"<p>Reverses the values in the array in place.</p>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.sort","title":"<code>sort(*, key=None, reverse=False)</code>","text":"<p>Sorts the values in the array in place.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[T, Any] | None</code> <p>A one-argument ordering function to use for comparison.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>If <code>True</code>, sort in descending order, otherwise sort in ascending order.</p> <code>False</code>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.swap","title":"<code>swap(i, j)</code>","text":"<p>Swaps the values at the given indices.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>Num</code> <p>The first index.</p> required <code>j</code> <code>Num</code> <p>The second index.</p> required"}]}