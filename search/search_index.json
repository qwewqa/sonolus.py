{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sonolus.py","text":""},{"location":"reference/builtins/","title":"Builtins","text":"<p>Sonolus.py comes with support for a number of built-in functions.</p> <ul> <li><code>abs(x)</code></li> <li><code>bool(object)</code> for a num argument</li> <li><code>callable(object)</code></li> <li><code>enumerate(iterable, start=0)</code></li> <li><code>filter(function, iterable)</code></li> <li><code>float(x)</code> for a num argument</li> <li><code>int(x)</code> for a num argument</li> <li><code>isinstance(object, classinfo)</code></li> <li><code>issubclass(class, classinfo)</code></li> <li><code>len(s)</code></li> <li><code>map(function, iterable)</code></li> <li><code>max(iterable, *, key=None)</code>, <code>max(arg1, arg2, *args, key=None)</code></li> <li><code>min(iterable, *, key=None)</code>, <code>min(arg1, arg2, *args, key=None)</code></li> <li><code>range(stop)</code>, <code>range(start, stop[, step])</code></li> <li><code>reversed(seq)</code></li> <li><code>round(number[, ndigits])</code></li> <li><code>zip(*iterables)</code></li> </ul>"},{"location":"reference/builtins/#standard-library-modules","title":"Standard library modules","text":"<p>Sonolus.py also comes with support for some standard library modules.</p>"},{"location":"reference/builtins/#math","title":"math","text":"<ul> <li><code>math.sin(x)</code></li> <li><code>math.cos(x)</code></li> <li><code>math.tan(x)</code></li> <li><code>math.asin(x)</code></li> <li><code>math.acos(x)</code></li> <li><code>math.atan(x)</code></li> <li><code>math.atan2(y, x)</code></li> <li><code>math.sinh(x)</code></li> <li><code>math.cosh(x)</code></li> <li><code>math.tanh(x)</code></li> <li><code>math.floor(x)</code></li> <li><code>math.ceil(x)</code></li> <li><code>math.trunc(x)</code></li> <li><code>math.log(x[, base])</code></li> </ul>"},{"location":"reference/builtins/#random","title":"random","text":"<ul> <li><code>random.randrange(stop)</code>, <code>random.randrange(start, stop[, step])</code></li> <li><code>random.randint(a, b)</code></li> <li><code>random.choice(seq)</code></li> <li><code>random.shuffle(seq)</code></li> <li><code>random.random()</code> (does not include 1)</li> <li><code>random.uniform(a, b)</code> (may include <code>b</code> where Python normally doesn't)</li> </ul>"},{"location":"reference/constructs/","title":"Constructs","text":"<p>Most standard Python constructs are supported in Sonolus.py.</p>"},{"location":"reference/constructs/#key-differences","title":"Key Differences","text":"<ul> <li>Non-num variables must have a single live definition.<ul> <li>If there are multiple definitions <code>var = ...</code> for a variable, the compiler must be able to determine that a single   one is active whenever the variable is used.</li> </ul> </li> <li>Conditional branches may be eliminated if they are determined to be unreachable</li> <li>Functions with non-num return types may not return multiple distinct objects<ul> <li>Most functions returning a non-num value should have a single return at the end</li> </ul> </li> <li>Destructuring assignment does not support the <code>*</code> operator.</li> <li>Sequence <code>match</code> patterns do not support the <code>*</code> operator.</li> <li>Mapping <code>match</code> patterns are unsupported.</li> <li>Imports may not be done within functions</li> <li>The <code>global</code> and <code>nonlocal</code> keywords are unsupported.</li> </ul>"},{"location":"reference/constructs/#overview","title":"Overview","text":"<ul> <li>Expressions:<ul> <li>Literals:<ul> <li>Numbers (excluding complex numbers): <code>0</code>, <code>1</code>, <code>1.0</code>, <code>1e3</code>, <code>0x1</code>, <code>0b1</code>, <code>0o1</code></li> <li>Booleans: <code>True</code>, <code>False</code></li> <li>Strings: <code>'Hello, World!'</code>, <code>\"Hello, World!\"</code></li> <li>Tuples: <code>(1, 2, 3)</code></li> </ul> </li> <li>Operators (if supported by the operands):<ul> <li>Unary: <code>+</code>, <code>-</code>, <code>not</code>, <code>~</code></li> <li>Binary: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li> <li>Comparison: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>is</code>, <code>is not</code>, <code>in</code>, <code>not in</code></li> <li>Logical: <code>and</code>, <code>or</code> (for <code>Num</code> arguments only)</li> <li>Ternary: <code>a if &lt;condition&gt; else b</code> (for <code>Num</code> conditions only)</li> <li>Attribute: <code>a.b</code></li> <li>Indexing: <code>a[b]</code></li> <li>Call: <code>f(a, b, c)</code></li> </ul> </li> <li>Variables: <code>a</code>, <code>b</code>, <code>c</code></li> <li>Lambda: <code>lambda a, b: a + b</code></li> <li>Assignment Expression: <code>(a := b)</code></li> </ul> </li> <li>Statements:<ul> <li>Simple Statements:<ul> <li>Assignments:<ul> <li>Simple assignment: <code>a = b</code></li> <li>Augmented assignment: <code>a += b</code></li> <li>Attribute assignment: <code>a.b = c</code></li> <li>Index assignment: <code>a[b] = c</code></li> <li>Destructuring assignment: <code>a, b = b, a</code></li> <li>Multiple assignment: <code>a = b = c = 1</code></li> <li>Annotated assignment: <code>a: int = 1</code></li> </ul> </li> <li>Assert: <code>assert &lt;condition&gt;, &lt;message&gt;</code></li> <li>Pass: <code>pass</code></li> <li>Break: <code>break</code></li> <li>Continue: <code>continue</code></li> <li>Return: <code>return &lt;value&gt;</code></li> <li>Import: <code>import &lt;module&gt;</code>, <code>from &lt;module&gt; import &lt;name&gt;</code> (only outside of functions)</li> </ul> </li> <li>Compound Statements:<ul> <li>If: <code>if &lt;condition&gt;:</code>, <code>elif &lt;condition&gt;:</code>, <code>else:</code></li> <li>While: <code>while &lt;condition&gt;:</code>, <code>else:</code></li> <li>For: <code>for &lt;target&gt; in &lt;iterable&gt;:</code>, <code>else:</code></li> <li>Match: <code>match &lt;value&gt;:</code>, <code>case &lt;pattern&gt;:</code></li> <li>Function Definition: <code>def &lt;name&gt;(&lt;parameters&gt;):</code></li> <li>Class Definition: <code>class &lt;name&gt;:</code> (only outside of functions)</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/constructs/#compile-time-evaluation","title":"Compile Time Evaluation","text":"<p>Some expressions can be evaluated at compile time:</p> <ul> <li>Numeric literals: <code>1</code>, <code>2.5</code>, <code>True</code>, <code>False</code>, ...</li> <li>None: <code>None</code></li> <li>Basic arithmetic: for compile time constant operands: <code>a + b</code>, <code>a - b</code>, <code>a * b</code>, <code>a / b</code>, ...</li> <li>Is/Is Not None: for any left-hand operand, <code>a is None</code>, <code>a is not None</code></li> <li>Type checks: for any value, <code>isinstance(a, t)</code>, <code>issubclass(a, t)</code></li> <li>Boolean operations:<ul> <li>Negation: <code>not a</code></li> <li>And<ul> <li>Both operands are compile time constants: <code>a and b</code></li> <li>One operand is known to be False: <code>False and a</code>, <code>a and False</code></li> </ul> </li> <li>Or<ul> <li>Both operands are compile time constants: <code>a or b</code></li> <li>One operand is known to be True: <code>True or a</code>, <code>a or True</code></li> </ul> </li> </ul> </li> <li>Comparison: for compile time constant operands: <code>a == b</code>, <code>a != b</code>, <code>a &gt; b</code>, <code>a &lt; b</code>, <code>a &gt;= b</code>, <code>a &lt;= b</code>, ...</li> <li>Variables assigned to compile time constants: <code>a = 1</code>, <code>b = a + 1</code>, ...</li> </ul> <p>The compiler can make additional inferences when compile time constants are used in certain contexts like control flow:</p> <pre><code>x = ...\n\n# This code works because the compiler knows which branch will be taken based on the type of 'x'\nif isinstance(x, Num):\n    debug_log(x)\nelif isinstance(x, Vec2):\n    debug_log(x.x + x.y)\nelse:\n    debug_log(-1)\n</code></pre>"},{"location":"reference/constructs/#variables","title":"Variables","text":"<p>Variables can be assigned and used like in vanilla Python.</p> <pre><code>a = 1\nb = 2\nc = a + b\n</code></pre> <p>Unlike vanilla Python, non-num variables must have a single unambiguous definition when used. Nums have no such restriction.</p> <p>The following are allowed:</p> <pre><code>v = Vec2(1, 2)  # (1)\nv = Vec2(3, 4)  # (2)\ndebug_log(v.x + v.y)  # 'v' is valid because (2) is the only active definition\n</code></pre> <pre><code>v = 1  # (1)\nv = Vec2(3, 4)  # (2)\ndebug_log(v.x + v.y)  # 'v' is valid because (2) is the only active definition\n</code></pre> <pre><code>v = Vec2(1, 2)  # (1)\nwhile condition():\n    v = Vec2(3, 4)  # (2)\n    debug_log(v.x + v.y)  # 'v' is valid because (2) is the only active definition\n</code></pre> <pre><code>v = Vec2(1, 2)  # (1)\nif random() &lt; 0.5:\n    v @= Vec2(3, 4)  # Updates 'v' in-place without redefining it\ndebug_log(v.x + v.y)  # 'v' is valid because (1) is the only active definition\n</code></pre> <p>The following are not allowed:</p> <pre><code>v = Vec2(1, 2)  # (1)\nif random() &lt; 0.5:\n    v = Vec2(3, 4)  # (2)\ndebug_log(v.x + v.y)  # 'v' is invalid because both (1) and (2) are active\n</code></pre> <pre><code>v = Vec2(1, 2)  # (1)\nwhile condition():\n    debug_log(v.x + v.y)  # 'v' is invalid because (1) and (2) are active\n    v = Vec2(3, 4)  # (2) redefines 'v' for future iterations\n</code></pre>"},{"location":"reference/constructs/#expressions","title":"Expressions","text":""},{"location":"reference/constructs/#literals","title":"Literals","text":"<p><code>int</code>, <code>float</code>, <code>bool</code>, <code>str</code>, and <code>tuple</code> literals are supported:</p> <pre><code>a = 1\nb = 1.0\nc = True\nd = 'Hello, World!'\ne = (1, 2, 3)\n</code></pre>"},{"location":"reference/constructs/#operators","title":"Operators","text":"<p>All standard operators are supported for types implementing them. <code>@=</code> is reserved as the copy-from operator.</p> <pre><code>a = 1 + 2\nb = 3 - 4\nc = 5 * 6\nd = 7 / 8\ne = Vec2(1, 2)\nf = e.x + e.y\ng = Array(1, 2, 3)\nh = g[0] + g[1] + g[2]\n(i := 1)\n</code></pre> <p>The ternary operator is supported for, but the condition must be a <code>Num</code>. If the operands are not nums, the condition must be a compile-time constant or this will be considered an error:</p> <pre><code># Ok\na = 1 if random() &lt; 0.5 else 2\nb = Vec2(1, 2) if b is None else b\n\n# Not ok\nc = Vec2(1, 2) if random() &lt; 0.5 else Vec2(3, 4)  # Multiple definitions\n</code></pre> <p>If the condition is a compile-time constant, then the ternary operator will be evaluated at compile time:</p> <pre><code>e = Vec2(0, 0) if e is None else e  # Ok, evaluated at compile time\n</code></pre>"},{"location":"reference/constructs/#statements","title":"Statements","text":""},{"location":"reference/constructs/#assignment","title":"Assignment","text":"<p>Most assignment types are supported. Destructuring assignment is supported only for tuples, and the <code>*</code> operator is not supported.</p> <pre><code># Ok\na = 1\nb += 2\nc.x = 3\nd[0] = 4\n(e, f), g = (1, 2), 3\n\n# Not ok\nh, *i = 1, 2, 3  # Not supported\n</code></pre> <pre><code>if a &gt; 0:\n    pass\n</code></pre>"},{"location":"reference/constructs/#conditional-statements","title":"Conditional Statements","text":"<p>The standard conditional statements are supported.</p>"},{"location":"reference/constructs/#if-elif-else","title":"if / elif / else","text":"<pre><code>if a &gt; 0:\n    ...\nelif a &lt; 0:\n    ...\nelse:\n    ...\n</code></pre> <p>When the condition is a compile-time constant, the compiler will remove the unreachable branches:</p> Code<pre><code>v = None\nif v is None:\n    v = Vec2(1, 2)\ndebug_log(v.x + v.y)\n</code></pre> Equivalent<pre><code>v = None\n# The 'if' branch is always taken\nv = Vec2(1, 2)\ndebug_log(v.x + v.y)\n</code></pre> <p>This is useful for handling optional arguments and supporting multiple argument types:</p> <pre><code>def f(a: Vec2 | None = None):\n    if a is None:\n        a = Vec2(1, 2)\n    debug_log(a.x + a.y)\n</code></pre> <pre><code>def f(a: Vec2 | int):\n    if isinstance(a, Vec2):\n        debug_log(a.x + a.y)\n    else:\n        debug_log(a)\n</code></pre>"},{"location":"reference/constructs/#match-case","title":"match / case","text":"<p>The <code>match</code> statement is supported for matching values against patterns. All patterns, including subpatterns, except mapping patterns and sequences with the <code>*</code> operator are supported.  Records have a <code>__match_args__</code> attribute defined automatically, so they can be used with positional subpatterns.</p> <pre><code>match x:\n    case 1:\n        ...\n    case 2 | 3:\n        ...\n    case Vec2() as v:\n        ...\n    case (a, b):\n        ...\n    case Num(a):\n        ...\n    case _:\n        ...\n</code></pre> <p>As with <code>if</code> statements, the compiler will remove unreachable branches when the value is a compile-time constant:</p> Code<pre><code>v = 1\nmatch v:\n    case Vec2(a, b):\n        debug_log(a + b)\n    case Num():\n        debug_log(v)\n    case _:\n        debug_log(-1)\n</code></pre> Equivalent<pre><code>v = 1\n# 'case Num()' is always taken\ndebug_log(v)\n</code></pre>"},{"location":"reference/constructs/#loops","title":"Loops","text":""},{"location":"reference/constructs/#while-else","title":"while / else","text":"<p>While loops are fully supported, including the <code>else</code> clause and the <code>break</code> and <code>continue</code> statements.</p> <pre><code>while a &gt; 0:\n    if ...:\n        break\n    if ...:\n        continue\n    ...\nelse:\n    ...\n</code></pre>"},{"location":"reference/constructs/#for-else","title":"for / else","text":"<p>For loops are supported, including the <code>else</code> clause and the <code>break</code> and <code>continue</code> statements. Custom iterators must subclass SonolusIterator.</p> <pre><code>for i in range(10):\n    if ...:\n        break\n    if ...:\n        continue\n    ...\nelse:\n    ...\n</code></pre> <p>Tuples can be iterated over and result in an unrolled loop. This can be useful for iterating of objects of different, types, but care should be taken since it results in more code being generated compared to a normal loop:</p> Code<pre><code>for i in (1, 2, 3):\n    debug_log(i)\n</code></pre> Equivalent<pre><code>debug_log(1)\ndebug_log(2)\ndebug_log(3)\n</code></pre>"},{"location":"reference/constructs/#functions","title":"Functions","text":"<p>Functions and lambdas are supported, including within other functions:</p> <pre><code>def f(a, b):\n    return a + b\n\n\ndef g(a):\n    return lambda b: f(a, b)\n</code></pre> <p>Function returns follow the same rules as variable access. If a function returns a non-num value, it most only return that value. There is no restriction of a function only returns a num.</p> <p>The following are allowed:</p> <pre><code>def f():\n    return Vec2(1, 2)\n</code></pre> <pre><code>def g(x):\n    # Only one return is reachable since isinstance is evaluated at compile time\n    if isinstance(x, Vec2):\n        return Vec2(x.y, x.x)\n    else:\n        return x\n</code></pre> <pre><code>def h(x):\n    # Both returns return the exact same value\n    x = Vec2(1, 2)\n    if random() &lt; 0.5:\n        debug_log(123)\n        return x\n    else:\n        return x\n</code></pre> <pre><code>def i(x):\n    # All return values are nums\n    if random() &lt; 0.5:\n        return 1\n    return 2\n</code></pre> <p>The following are not allowed:</p> <pre><code>def j():\n    # Either return is reachable and return different values\n    if random() &lt; 0.5:\n        return Vec2(1, 2)\n    return Vec2(3, 4)\n</code></pre> <pre><code>def k():\n    # Both the return and an implicit 'return None' are reachable\n    if random() &lt; 0.5:\n        return Vec2(1, 2)\n</code></pre> <p>Most functions returning a non-num value should have a single <code>return</code> statement at the end.</p>"},{"location":"reference/constructs/#classes","title":"Classes","text":"<p>Classes are supported at the module level. User defined classes should subclass <code>Record</code> or have a supported Sonolus.py decorator such as <code>@level_memory</code>.</p> <p>Methods may have the <code>@staticmethod</code>, <code>@classmethod</code>, or <code>@property</code> decorators.</p> <pre><code>class MyRecord(Record):\n    x: int\n    y: int\n\n    def regular_method(self):\n        ...\n\n    @staticmethod\n    def static_method():\n        ...\n\n    @classmethod\n    def class_method(cls):\n        ...\n\n    @property\n    def property(self):\n        ...\n</code></pre>"},{"location":"reference/constructs/#imports","title":"Imports","text":"<p>Imports are supported at the module level, but not within functions.</p>"},{"location":"reference/constructs/#assert","title":"assert","text":"<p>Assertions are supported. Since error handling is not supported, assertion failures will terminate the current callback when running in the Sonolus app.</p> <pre><code>assert a &gt; 0, 'a must be positive'\n</code></pre>"},{"location":"reference/constructs/#pass","title":"pass","text":"<p>The <code>pass</code> statement is supported.</p>"},{"location":"reference/types/","title":"Types","text":"<p>Sonolus.py has 3 core types: <code>Num</code>, <code>Array</code>, and <code>Record</code>. representing numeric values, fixed-size arrays,  and custom data structures, respectively. Arrays and records can be nested within each other to create complex data structures. The standard library provides additional types and functions for common tasks.</p> <p>Additionally, Sonolus.py supports the built-in types <code>tuple</code>, <code>dict</code>, <code>str</code>, classes and functions, and the constants <code>None</code>, <code>Ellipsis</code>, and <code>NotImplemented</code>.</p>"},{"location":"reference/types/#num","title":"Num","text":"<p><code>Num</code> is the numeric and boolean type in Sonolus.py. It is interchangeable with <code>int</code>, <code>float</code>, and <code>bool</code>. Sonolus.py will treat any of these types as <code>Num</code>, but it's recommended to use what's appropriate for clarity.</p> <p>The Sonolus app uses 32-bit floating-point numbers for all numeric values, so precision may be lower compared to Python when running on Sonolus.</p> <p>Infinity, NaN, and values outside the range of 32-bit floating-point numbers are not supported.</p> <p>You can import <code>Num</code> from <code>sonolus.script.num</code>:</p> <pre><code>from sonolus.script.num import Num\n</code></pre>"},{"location":"reference/types/#declaration","title":"Declaration","text":"<p>Nums can be declared using standard Python syntax.</p> <pre><code>a = 1\nb = 2.5\nc = True\n</code></pre>"},{"location":"reference/types/#operations","title":"Operations","text":"<p>Nums support most of the standard Python operations:</p> <ul> <li>Comparison operators: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> <li>Arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code></li> <li>Unary operators: <code>+</code>, <code>-</code></li> </ul> <p>Nums are the only supported type for boolean operations and control flow conditions. As a condition, any nonzero value is considered true, and <code>0</code> is considered false.</p> <ul> <li>Logical operators: <code>and</code>, <code>or</code>, <code>not</code></li> <li>Ternary expressions: <code>... if &lt;condition&gt; else ...</code></li> <li>If statements: <code>if &lt;condition&gt;:</code>, <code>elif &lt;condition&gt;:</code></li> <li>While loops: <code>while &lt;condition&gt;:</code></li> <li>Case guards: <code>case ... if &lt;condition&gt;:</code></li> </ul>"},{"location":"reference/types/#instance-checks","title":"Instance Checks","text":"<p>Since <code>Num</code> is interchangeable with <code>int</code>, <code>float</code>, and <code>bool</code>, only <code>Num</code> is supported for type checks.</p> <pre><code>x = ...\n\n# Ok:\nisinstance(x, Num)\n\nmatch x:\n    case Num(value):\n        ...\n\n# Not ok:\nisinstance(x, int)\nisinstance(x, float)\nisinstance(x, bool)\n\nmatch x:\n    case int(value):\n        ...\n    case float(value):\n        ...\n    case bool(value):\n        ...\n</code></pre>"},{"location":"reference/types/#conversion","title":"Conversion","text":"<p>Calling <code>int</code>, <code>float</code>, or <code>bool</code> is only supported for an argument of type <code>Num</code>.</p> <p>Details:</p> <ul> <li><code>int</code>: Equivalent to <code>math.trunc</code>.</li> <li><code>float</code>: Validates that the value is a <code>Num</code> and returns it as is.</li> <li><code>bool</code>: Validates that the value is a <code>Num</code> and returns <code>1</code> for <code>True</code> and <code>0</code> for <code>False</code>.</li> </ul>"},{"location":"reference/types/#array","title":"Array","text":"<p><code>Array[T, Size]</code> stores a fixed number of elements of the same type.</p> <p>It has two type parameters: - <code>T</code>: The type of the elements. - <code>Size</code>: The number of elements.</p> <p>You can import <code>Array</code> from <code>sonolus.script.array</code>:</p> <pre><code>from sonolus.script.array import Array\n</code></pre>"},{"location":"reference/types/#declaration_1","title":"Declaration","text":"<p>Arrays can be created using its constructor:</p> <pre><code>a1 = Array[int, 3](1, 2, 3)\na2 = Array[int, 0]()\n</code></pre> <p>If at least one element is provided, the element type and size can be inferred:</p> <pre><code>a3 = Array(1, 2, 3)\n</code></pre> <p>Since <code>Array</code> takes type parameters, it is considered a generic type. A version of <code>Array</code> with type parameters provided is considered a concrete type.</p> <pre><code>Array  # The Generic Array type\nArray[int, 3]  # A concrete Array type\n</code></pre> <p>The element type of an array must be concrete (not generic) and the size must be a non-negative integer:</p> <pre><code># Ok\na4 = Array[Array[int, 3], 2](Array(1, 2, 3), Array(4, 5, 6))\n\n# Not ok:\na5 = Array[int, 0.5]()  # The size must be a non-negative integer\na6 = Array[Array, 2](Array(1, 2, 3), Array(4, 5, 6))  # The element type must be concrete (not generic)\n</code></pre> <p>Copies are made of any values provided to the constructor:</p> <pre><code>pair = Pair(1, 2)\na = Array[Pair, 1](pair)\nassert a[0] == Pair(1, 2)\n\npair.x = 3\nassert a[0] == Pair(1, 2)  # The value in the array is independent of the original value\n</code></pre>"},{"location":"reference/types/#operations_1","title":"Operations","text":"<p>The value of an array can be copied from another array using the copy from operator (<code>@=</code>)<sup>1</sup>:</p> <pre><code>source_array = Array(1, 2, 3)\ndestination_array = Array(0, 0, 0)\n\ndestination_array @= source_array\nassert destination_array == Array(1, 2, 3)\n</code></pre> <p>Arrays can be compared for equality and inequality:</p> <pre><code>assert Array(1, 2, 3) == Array(1, 2, 3)\nassert Array(1, 2, 3) != Array(4, 5, 6)\n</code></pre> <p>Elements can be accessed by index:</p> <pre><code>a = Array(1, 2, 3)\nassert a[0] == 1\nassert a[1] == 2\nassert a[2] == 3\n</code></pre> <p>Elements can be updated by index, copying the given value into the corresponding element of the array:</p> <pre><code>a = Array(1, 2, 3)\na[0] = 4\nassert a == Array(4, 2, 3)\n</code></pre> <p>Warning</p> <p>If a value in an array is not a <code>Num</code>, updating it will copy the given value into the corresponding element of the array. However, that element remains independent of the original value, which may lead to unexpected results when updating either value.</p> <pre><code>pair = Pair(1, 2)\na = Array(Pair(0, 0))\n\na[0] = pair  # or equivalently: a[0] @= pair\nassert a[0] == Pair(1, 2)\n\npair.x = 3\nassert a[0] == Pair(1, 2)  # The value in the array is independent of the original value\n</code></pre> <p>For clarity, it's recommended to use the copy from operator (<code>@=</code>) when updating elements that are known to be an array or record (see the next section).</p> <pre><code>a[0] @= pair\n</code></pre> <p>The length of an array can be accessed using the <code>len()</code> function:</p> <pre><code>assert len(Array(1, 2, 3)) == 3\n</code></pre> <p>Arrays can be iterated over using a for loop:</p> <pre><code>a = Array(1, 2, 3)\n\nfor element in a:\n    debug_log(element)\n</code></pre> <p>Other functionality:</p> <p><code>Array</code> inherits from ArrayLike and supports all of its methods.</p>"},{"location":"reference/types/#instance-checks_1","title":"Instance Checks","text":"<p>Any array is considered an instance of the generic <code>Array</code> type.</p> <pre><code>a = Array(1, 2, 3)\nassert isinstance(a, Array)\n</code></pre> <p>Only an array with the exact element type and size is considered an instance of a concrete <code>Array[T, Size]</code> type.</p> <pre><code>a = Array(1, 2, 3)\nassert isinstance(a, Array[int, 3])\nassert not isinstance(a, Array[int, 2])\nassert not isinstance(a, Array[Pair, 3])\n</code></pre>"},{"location":"reference/types/#record","title":"Record","text":"<p><code>Record</code> is the base class for user-defined types in Sonolus.py. It functions similarly to dataclasses.</p> <p>You can import <code>Record</code> from <code>sonolus.script.record</code>:</p> <pre><code>from sonolus.script.record import Record\n</code></pre>"},{"location":"reference/types/#declaration_2","title":"Declaration","text":"<p>A record can be defined by inheriting from <code>Record</code> and defining zero or more fields as class attributes:</p> <pre><code>class MyPair(Record):\n    first: int\n    second: int\n</code></pre> <p>Fields must be annotated by <code>Num</code> (or equivalently <code>int</code>, <code>float</code>, or <code>bool</code>),  a concrete array type, or a concrete record type.</p> <pre><code># Not ok:\nclass MyRecord(Record):\n    array: Array  # Array is not concrete since it has unspecified type parameters\n</code></pre> <p>A <code>Record</code> subclass cannot be further subclassed.</p> <pre><code># Not ok:\nclass MyPairSubclass(MyPair):\n    third: int\n</code></pre>"},{"location":"reference/types/#instantiation","title":"Instantiation","text":"<p>A constructor is automatically generated for the <code>Record</code> class:</p> <pre><code>pair_1 = MyPair(1, 2)\npair_2 = MyPair(first=1, second=2)\n</code></pre>"},{"location":"reference/types/#generics","title":"Generics","text":"<p><code>Record</code> supports generics. If at least one type parameter is provided in the class definition, a generic  record type is created.</p> <pre><code>class MyGenericPair[T, U](Record):\n    first: T\n    second: U\n\nclass ContainsArray[T, Size](Record):\n    array: Array[T, Size]\n</code></pre> <p>Generic type parameters can be specified explicitly when instantiating a generic or inferred from the provided values:</p> <pre><code>pair_1 = MyGenericPair[int, int](1, 2)\npair_2 = MyGenericPair(1, 2)\n</code></pre> <p>The value of a type parameter can be accessed via the <code>type_var_value()</code> classmethod.</p> <pre><code>class MyGenericRecord[T](Record):\n    value: T\n\n    def my_type(self) -&gt; type:\n        return self.type_var_value(T)\n\n\nassert MyGenericRecord(1).my_type() == Num\n</code></pre>"},{"location":"reference/types/#operations_2","title":"Operations","text":"<p>The value of a record can be copied from another record using the copy from operator (<code>@=</code>)<sup>1</sup>:</p> <pre><code>source_record = MyPair(1, 2)\ndestination_record = MyPair(0, 0)\n\ndestination_record @= source_record\nassert destination_record == MyPair(1, 2)\n</code></pre> <p>Records can be compared for equality and inequality:</p> <pre><code>assert MyPair(1, 2) == MyPair(1, 2)\nassert MyPair(1, 2) != MyPair(3, 4)\n</code></pre> <p>Dunder methods can be implemented to define custom behavior for records:</p> <pre><code>class MyAddablePair(Record):\n    first: int\n    second: int\n\n    def __add__(self, other: MyAddablePair) -&gt; MyAddablePair:\n        return MyAddablePair(self.first + other.first, self.second + other.second)\n</code></pre> <p>If a dunder method has an in-place variant and the in-place method is not explicitly implemented (e.g. <code>__iadd__</code> is the in-place variant of <code>__add__</code>), <code>Record</code> will automatically generate one that  modifies the instance in place:</p> <pre><code>pair = MyAddablePair(1, 2)\nreference = pair\npair += MyAddablePair(3, 4)\nassert pair == reference == MyAddablePair(4, 6)  # The instance is modified in place\n</code></pre> <p>Regular methods, properties, classmethods, and staticmethods can also be defined in a <code>Record</code> subclass.</p> <pre><code>class MyRecord(Record):\n    def my_method(self):\n        ...\n\n    @property\n    def my_property(self):\n        ...\n\n    @property.setter\n    def my_property(self, value):\n        ...\n\n    @classmethod\n    def my_classmethod(cls):\n        ...\n\n    @staticmethod\n    def my_staticmethod():\n        ...\n</code></pre> <p>Fields can be accessed and updated using the dot operator:</p> <pre><code>pair = MyPair(1, 2)\nassert pair.first == 1\nassert pair.second == 2\n\npair.first = 3\nassert pair == MyPair(3, 2)\n</code></pre> <p>Warning</p> <p>If a value in a record is not a <code>Num</code>, updating it will copy the given value into the corresponding field of the record. However, that field remains independent of the original value.</p> <pre><code>array = Array(1, 2, 3)\nrecord = MyRecord(array)\n\nrecord.array = Array(4, 5, 6)  # or equivalently: record.array @= Array(4, 5, 6)\nassert record.array == Array(4, 5, 6)\n\narray[0] = 7\nassert record.array == Array(4, 5, 6)  # The value in the record is independent of the original\n</code></pre> <p>For clarity, it's recommended to use the copy from operator (<code>@=</code>) when updating fields that are known to be an array or record.</p> <pre><code>record.array @= array\n</code></pre>"},{"location":"reference/types/#instance-checks_2","title":"Instance Checks","text":"<p>Any record is considered an instance of the generic <code>Record</code> type:</p> <pre><code>pair = MyPair(1, 2)\nassert isinstance(pair, Record)\n</code></pre> <p>If a record is generic, any instance of it is considered an instance of the generic type:</p> <pre><code>pair = MyGenericPair[int, int](1, 2)\nassert isinstance(pair, MyGenericPair)\n</code></pre> <p>Only an instance of a record with the exact field types is considered an instance of a concrete <code>Record</code> type:</p> <pre><code>pair = MyPair(1, 2)\nassert isinstance(pair, MyPair[int, int])\nassert not isinstance(pair, MyPair[int, Array[int, 2]])\n</code></pre>"},{"location":"reference/types/#transient-types","title":"Transient Types","text":"<p>In addition to the standard types, the following transient types are available. Compared to the standard types, these types come with the restriction that they cannot be used as type parameters or as a Record field's type. Otherwise, they can be used like any other type, including passing instances of them as  arguments to functions.</p>"},{"location":"reference/types/#tuple","title":"tuple","text":"<p>The built-in <code>tuple</code> type can be declared and destructured as usual:</p> <pre><code>t = (1, (2, 3))\na, (b, c) = t\n</code></pre> <p>Tuples may be indexed, but the given index must be a compile-time constant:</p> <pre><code>t = (1, 2, 3)\n\n# Ok\ndebug_log(t[0])\n\n# Not ok:\ndebug_log(t[random_integer(0, 2)])\n</code></pre> <p>They may also be created as an *args argument to a function and unpacked as an argument to a function:</p> <pre><code>def f1(a, b, c):\n    return a + b + c\n\ndef f2(*args):\n    return f1(*args)\n</code></pre> <p>Iterating over a tuple is also supported, but they are expanded at compile time, so iterating over large tuples may significantly increase the size of the compiled engine and slow down compilation:</p> <pre><code>t = (1, 2, 3)\nfor x in t:\n    debug_log(x)\n</code></pre>"},{"location":"reference/types/#dict","title":"dict","text":"<p>Dicts can be created by the **kwargs syntax and unpacked as arguments to a function:</p> <pre><code>def f1(a, b):\n    return a + b\n\ndef f2(**kwargs):\n    return f1(**kwargs)\n</code></pre>"},{"location":"reference/types/#str","title":"str","text":"<p>Strings can be created and compared for equality and inequality:</p> <pre><code>s1 = 'abc'\ns2 = 'def'\n\nassert s1 == 'abc'\nassert s1 != s2\n</code></pre>"},{"location":"reference/types/#special-constants","title":"Special Constants","text":"<p>The built-in <code>None</code>, <code>Ellipsis</code>, and <code>NotImplemented</code> constants are supported.</p> <p><code>None</code> is the only supported right-side operand for the <code>is</code> and <code>is not</code> operators.</p> <pre><code>a = None\nb = 1\n\n# Ok\na is None\nb is not None\n\n# Not ok:\nb is b\n</code></pre>"},{"location":"reference/types/#other-types","title":"Other types","text":"<p>Classes themselves are considered instances of <code>type</code>. They may be used as arguments to functions, but annotating a record field as <code>type</code> or declaring an array with element type <code>type</code> is not supported.</p> <p>Functions or methods may be used as arguments to functions, but annotating a record field or setting an array element type to <code>Callable</code> is not supported.</p>"},{"location":"reference/types/#storing-instances-of-transient-types-in-records","title":"Storing Instances of Transient Types in Records","text":"<p>Warning</p> <p>The following is advanced usage and is unnecessary for most use cases.</p> <p>While transient types cannot be used as type parameters or as a Record field's type, it is possible to store them in a generic record in a field annotated by a type parameter. Type arguments must not be explicitly provided when doing so. If multiple fields are annotated by the same type parameter, all such fields may be required to hold the exact same value in some cases.</p> <p>For example, a version of the <code>filter</code> function can be implemented as follows (see Iterables for more information on iterators):</p> <pre><code>class _FilteringIterator[T, Fn](Record, SonolusIterator):\n    fn: Fn\n    iterator: T\n\n    def has_next(self) -&gt; bool:\n        while self.iterator.has_next():\n            if self.fn(self.iterator.get()):\n                return True\n            self.iterator.advance()\n        return False\n\n    def get(self) -&gt; Any:\n        return self.iterator.get()\n\n    def advance(self):\n        self.iterator.advance()\n\n\ndef my_filter[T, Fn](iterable: T, fn: Fn) -&gt; T:\n    return _FilteringIterator(fn, iterable.__iter__())\n</code></pre> <ol> <li> <p>The copy from operator (<code>@=</code>) is officially the in-place matrix multiplication operator in Python, but it has been repurposed in Sonolus.py for copying Arrays and Records.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"reference/standard_library/","title":"Standard Library","text":"<p>In addition to core types and builtin functions, Sonolus.py comes with a standard library of useful  functions and classes.</p>"},{"location":"reference/standard_library/array_like/","title":"sonolus.script.array_like","text":""},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike","title":"<code>ArrayLike</code>","text":"<p>               Bases: <code>Sequence</code>, <code>ABC</code></p> <p>Mixin for array-like objects.</p> <p>Inheritors must implement <code>__len__</code>, <code>__getitem__</code>, and <code>__setitem__</code>.</p> Usage <pre><code>class MyArrayLike[T](Record, ArrayLike[T]):\n    def __len__(self) -&gt; int:\n        ...\n\n    def __getitem__(self, index: Num) -&gt; T:\n        ...\n\n    def __setitem__(self, index: Num, value: T):\n        ...\n</code></pre>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.__contains__","title":"<code>__contains__(value)</code>","text":"<p>Returns whether any element in the array is equal to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to check for.</p> required"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.__getitem__","title":"<code>__getitem__(index)</code>  <code>abstractmethod</code>","text":"<p>Returns the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Num</code> <p>The index of the item. Must be an integer between 0 and <code>len(self) - 1</code>.</p> required"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.__iter__","title":"<code>__iter__()</code>","text":"<p>Returns an iterator over the array.</p>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.__len__","title":"<code>__len__()</code>  <code>abstractmethod</code>","text":"<p>Returns the length of the array.</p>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.__reversed__","title":"<code>__reversed__()</code>","text":"<p>Returns a reversed view of the array.</p>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.__setitem__","title":"<code>__setitem__(index, value)</code>  <code>abstractmethod</code>","text":"<p>Sets the value of the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Num</code> <p>The index of the item. Must be an integer between 0 and <code>len(self) - 1</code>.</p> required <code>value</code> <code>T</code> <p>The value to set.</p> required"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.count","title":"<code>count(value)</code>","text":"<p>Returns the number of elements in the array equal to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to count.</p> required"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.index","title":"<code>index(value, start=0, stop=None)</code>","text":"<p>Returns the index of the value in the array equal to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to search for.</p> required <code>start</code> <code>Num</code> <p>The index to start searching from.</p> <code>0</code> <code>stop</code> <code>Num | None</code> <p>The index to stop searching at. If <code>None</code>, search to the end of the array.</p> <code>None</code>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.last_index","title":"<code>last_index(value)</code>","text":"<p>Returns the last index of the value in the array equal to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to search for.</p> required"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.reverse","title":"<code>reverse()</code>","text":"<p>Reverses the values in the array in place.</p>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.shuffle","title":"<code>shuffle()</code>","text":"<p>Shuffles the values in the array in place.</p>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.sort","title":"<code>sort(*, key=None, reverse=False)</code>","text":"<p>Sorts the values in the array in place.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[T, Any] | None</code> <p>A one-argument ordering function to use for comparison.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>If <code>True</code>, sort in descending order, otherwise sort in ascending order.</p> <code>False</code>"},{"location":"reference/standard_library/array_like/#sonolus.script.array_like.ArrayLike.swap","title":"<code>swap(i, j)</code>","text":"<p>Swaps the values at the given indices.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>Num</code> <p>The first index.</p> required <code>j</code> <code>Num</code> <p>The second index.</p> required"},{"location":"reference/standard_library/iterator/","title":"sonolus.script.iterator","text":""},{"location":"reference/standard_library/iterator/#sonolus.script.iterator.SonolusIterator","title":"<code>SonolusIterator</code>","text":"<p>               Bases: <code>Iterator[T]</code></p>"}]}